'************************************
'*  Spin2 Interpreter - 2023.11.11  *
'************************************
'
CON     bc_setup_reg_1D8_1F8    = $B0
        bc_setup_var_0_15       = $C0
        bc_setup_local_0_15     = $D0
        bc_read_local_0_15      = $E0
        bc_write_local_0_15     = $F0
'
'
' Set clock mode, clear first 16 hub longs and VAR space, then start interpreter
'
DAT             org

                mov     y,clkmode_hub           'set clock mode
                mov     z,clkfreq_hub
                call    #clkset_init

                setq    #16-1                   'clear $00..$3F in hub (this code space)
                wrlong  #0,#0

                setq    var_longs               'clear VAR space
                wrlong  #0,vbase_init

                setq    #2-1                    'init stack with pbase/vbase
                wrlong  pbase_init,dbase_init

                setq    dbase_init              'restart cog 0 with interpreter
                coginit #hubexec,##launch_spin


pbase_init      long    @test_pbase + 8                         '$30 - compiler supplies initial pbase value, +8 without compiler
vbase_init      long    @test_vbase + 0 << 20                   '$34 - compiler supplies initial vbase value, first pub in [31:20]
dbase_init      long    @test_dbase                             '$38 - compiler supplies initial dbase value
var_longs       long    (@test_dbase - @test_vbase) >> 2        '$3C - compiler supplies VAR longs to clear
clkmode_hub     long    %1_000000_0000001111_1111_10_11         '$40 - compiler supplies initial clkmode value
clkfreq_hub     long    320_000_000                             '$44 - compiler supplies initial clkfreq value
'
'
' Unaligned data
'
                orgh

stopcog         byte    bc_cogid                & $FF   'cogstop(cogid)
                byte    bc_cogstop              & $FF

pri_sendb       byte    0                               'no locals              PRI sendb(count,addr)
                byte    bc_read_local_0_15+0            'read count               repeat count
.loop           byte    bc_setup_local_0_15+1           'setup addr                 send(byte[addr++])
                byte    bc_var_postinc_push     & $FF   'addr++
                byte    bc_setup_byte_pa        & $FF   'setup byte
                byte    bc_read                 & $FF   'read
                byte    bc_call_send            & $FF   'call send
                byte    bc_djnz                 & $FF   'djnz
                byte    (.loop-$) & $7F                 'loop address
                byte    bc_return_results       & $FF   'return
'
'
' Hub bytecode vectors (up to $FE possible)
'
                alignw                  'word-align for vectors

bc_hubset       word    @hubset_        'HUBSET(val)                            $54     miscellaneous routines
bc_clkset       word    @clkset_        'CLKSET(clkmode,clkfreq)                $56     (use ctrl-l to determine address)
bc_read_clkfreq word    @read_clkfreq   'CLKFREQ                        (push)  $58
bc_cogspin      word    @cogspin_       'COGSPIN(cog,method(params),stackadr)   $5A
bc_cogchk       word    @cogchk_        'COGCHK(cog)                    (push)  $5C
bc_inline       word    @inline         'inline pasm code                       $5E
bc_regexec      word    @regexec_       'REGEXEC(hubadr)                        $60
bc_regload      word    @regload_       'REGLOAD(hubadr)                        $62
bc_call         word    @call_          'CALL(anyadr)                           $64
bc_getregs      word    @getregs_       'GETREGS(hubadr,cogadr,longs)           $66
bc_setregs      word    @getregs_       'SETREGS(hubadr,cogadr,longs)           $68
bc_bytemove     word    @bytemove_      'BYTEMOVE(dst,src,cnt)                  $6A     (+0, bit1=1)
bc_bytefill     word    @bytemove_      'BYTEFILL(dst,val,cnt)                  $6C     (+2, bit1=0)
bc_wordmove     word    @wordmove_      'WORDMOVE(dst,src,cnt)                  $6E     (+4, bit1=1)
bc_wordfill     word    @wordmove_      'WORDFILL(dst,val,cnt)                  $70     (+6, bit1=0)
bc_longmove     word    @longmove_      'LONGMOVE(dst,src,cnt)                  $72     (+8, bit1=1)
bc_longfill     word    @longmove_      'LONGFILL(dst,val,cnt)                  $74     (+A, bit1=0)
bc_strsize      word    @strsize_       'STRSIZE(adr)                   (push)  $76
bc_strcomp      word    @strcomp_       'STRCOMP(adra,adrb)             (push)  $78
bc_strcopy      word    @strcopy_       'STRCOPY(dst,src,max)                   $7A
bc_getcrc       word    @getcrc_        'GETCRC(ptr,poly,cnt)           (push)  $7C
bc_waitus       word    @waitus_        'WAITUS(us)                             $7E
bc_waitms       word    @waitus_        'WAITMS(ms)                             $80
bc_getms        word    @getms_         'GETMS()                        (push)  $82
bc_getsec       word    @getms_         'GETSEC()                       (push)  $84
bc_muldiv64     word    @muldiv64_      'MULDIV64(m1,m2,d)              (push)  $86
bc_qsin         word    @qsin_          'QSIN(rho,theta,twopi)          (push)  $88
bc_qcos         word    @qsin_          'QCOS(rho,theta,twopi)          (push)  $8A
bc_rotxy        word    @rotxy_         'ROTXY(x,y,t)                   (push2) $8C     (<bc_polxy)
bc_polxy        word    @polxy_         'POLXY(r,t)                     (push2) $8E     (=bc_polxy)
bc_xypol        word    @polxy_         'XYPOL(x,y)                     (push2) $90     (>bc_polxy)

bc_nan          word    @nan_           'NAN(float)                     (push)  $92     floating-point routines
bc_fneg         word    @fneg_          '-. float                       (push)  $94
bc_fabs         word    @fabs_          'FABS(float)                    (push)  $96
bc_fsqrt        word    @fsqrt_         'FSQRT(float)                   (push)  $98
bc_fadd         word    @fadd_          'float +. float                 (push)  $9A
bc_fsub         word    @fsub_          'float -. float                 (push)  $9C
bc_fmul         word    @fmul_          'float *. float                 (push)  $9E
bc_fdiv         word    @fdiv_          'float /. float                 (push)  $A0
bc_flt          word    @frel_          'float <.  float                (push)  $A2     (bit3..1=001)
bc_fgt          word    @frel_          'float >.  float                (push)  $A4     (bit3..1=010)
bc_fne          word    @frel_          'float <>. float                (push)  $A6     (bit3..1=011)
bc_fe           word    @frel_          'float ==. float                (push)  $A8     (bit3..1=100)
bc_flte         word    @frel_          'float <=. float                (push)  $AA     (bit3..1=101)
bc_fgte         word    @frel_          'float >=. float                (push)  $AC     (bit3..1=110)
bc_round        word    @round_         'ROUND(float)                   (push)  $AE     (bit1=1)
bc_trunc        word    @round_         'TRUNC(float)                   (push)  $B0     (bit1=0)
bc_float        word    @float_         'FLOAT(integer)                 (push)  $B2

                alignl                  'long-align for rest of interpreter
'
'
'*********************************
'*  Interpreter - cog registers  *
'*********************************
'
                org     $120            'start of reg code (user area below)
reg_code
'
'
' RETURN                                (1 long)
'
return_         jmp     #returnh        'continue in hub
'
'
' ABORT                                 (1 long)
'
abort_          jmp     #aborth         'continue in hub
'
'
' Miscellaneous                         (17 longs)
'
pop2            mov     w,x             '  b c d e f g          a: CASE done
cased           setq    #2-1            'a b c d e f g          b: PINWRITE(pins,val)
                rdlong  x,--ptra        'a b c d e f g          c: WRPIN(pins,val)
                add     y,pbase         'a | | | | | |          d: WXPIN(pins,val)
        _ret_   rdfast  #0,y            'a | | | | | |          e: WYPIN(pins,val)
                jmp     #pinw_          '  b | | | | |          f: COGINIT(cog,pgm,ptr) (push)
        _ret_   wrpin   w,y             '    c | | | |          g: COGINIT(cog,pgm,ptr)
        _ret_   wxpin   w,y             '      d | | |          h: COGSTOP(cog)
        _ret_   wypin   w,y             '        e | |          i: LOCKRET(lock)
                setq    w               '          f g          j: LOCKREL(lock)
                coginit x,y     wc      '          f g          k: COGATN(mask)
        _ret_   bitc    x,#31           '          f |
cogstop_        cogstop x               '            | h
lockret_        lockret x               '            | | i
lockrel_        lockrel x               '            | | | j
cogatn_         cogatn  x               '            | | | | k
        _ret_   popa    x               '            g h i j k
'
'
' Miscellaneous                         (29 longs)
'
debug_          pusha   x               'a                      a: DEBUG()
popx            rfvar   x               'a b                    b: pop #rfvar
                sub     ptra,x          'a b                    c: PINLOW(pins)
pinl_           drvl    x               '| | c                  d: PINHIGH(pins)
pinh_           drvh    x               '| | | d                e: PINTOGGLE(pins)
pint_           drvnot  x               '| | | | e              f: PINFLOAT(pins)
pinf_           fltl    x               '| | | | | f g          g: PINCLEAR(pins)
                wrpin   #0,x            '| | | | | | g          h: AKPIN(pins)
akpin_          akpin   x               '| | | | | | | h
pop1    _ret_   popa    x               '| b c d e f g h
                popa    x               'a                      (continued in string_ + branch + hub_code)
'
'
' STRING()
'
string_         rfbyte  w               'a b                    b: STRING() - push string address and jump over string
        _ret_   brk     w               'a |
                pusha   x               '  b
                add     pb,#1           '  b
                mov     x,pb            '  b                    (continued in branch + hub_code)
'
'
' Branches - jmp, jz, jnz, tjz, djnz
'
branch          rfvars  w               '  | c d e f g          c: jmp  - branch
                test    x       wz      '  | | d e f |          d: jz   - test, pop, branch if z
                popa    x               '  | | d e | |          e: jnz  - test, pop, branch if nz
        if_nz   ret                     '  | | d | f |          f: tjz  - test, if z then pop and branch
                sub     x,#1    wz      '  | | | | | g          g: djnz - dec, if z then pop, else branch
        if_z    popa    x               '  | | | | f g
        if_z    ret                     '  | | | e | g
                add     pb,w            '  b c d e f g          (continued in hub_code)
'
'
' Call hub bytecode routine
'
hub_code        rfbyte  pa              '  | | | | | |          get function index byte
                getptr  pb              '  | | | | | |          get updated bytecode pointer
                rdword  v,pa    wcz     '  | | | | | |          lookup function address
                call    v               '  | | | | | |          call function in hub, c/z/v[31]=0
resume  _ret_   rdfast  #0,pb           '  b c d e f g          resume bytecode stream
'
'
' Variable assignments / math operators (21 longs)
'
una_iso         mov     w,x             '       m                               a: !!
una_psh         pusha   x               'push   | n                             b: !
                alti    rd              'rd     m n                             c: - (neg)
op_notb         test    x       wz      'rd,!!  m n a                           d: ABS
op_quna         rep     #99,#1          '       x x |               i j k       e: ENCOD        use REP to protect cordic operation until ret/_ret_
                qsqrt   x,#0            'SQRT   x x |               i | |       f: DECOD
                qlog    x               'LOG    x x |               | j |       g: BMASK
                qexp    x               'EXP    x x |               | | k       h: ONES
                muxz    x,_FFFFFFFF     '!!     x x a               | | |       i: SQRT
op_not          not     x               '!      x x | b             | | |       j: QLOG
op_neg          neg     x               '-      x x | | c           | | |       k: QEXP
op_abs          abs     x               'ABS    x x | | | d         | | |
op_encod        encod   x               'ENCOD  x x | | | | e       | | |
op_decod        decod   x               'DECOD  x x | | | | | f     | | |
op_bmask        bmask   x               'BMASK  x x | | | | | | g   | | |
op_ones         ones    x               'ONES   x x | | | | | | | h | | |
                getqx   x               '       x x | | | | | | | | i j k
                alti    wr              'wr     m n | | | | | | | | | | |
                ret                     'wr,op  m n a b c d e f g h i j k       m: ?= var       (isolated)
        _ret_   mov     x,w             'iso    m |                             n: ?= var       (push)
        _ret_   zerox   x,sz            'push     n                             x: use a..k
'
'
' Variable assignments / math operators (16 longs)
'
sha_mod         mov     w,x             '       x x a b c d e       i j         a: >>
rev_mod         not     w,x             '       x x | | | | | f g h | |         b: <<
                alti    rd              'rd     m n | | | | | | | | | |         c: SAR
                popa    x               'rd,op  m n a b c d e f g h i j         d: ROR
                rev     x               'REV    x x | | | | | f | | | |         e: ROL
                shl     x,w             '<<     x x | b | | | | g h | |         f: REV
                shr     x,w             '>>     x x a | | | | f g | | |         g: ZEROX
                sar     x,w             'SAR    x x | | c | | | | h | |         h: SIGNX
                ror     x,w             'ROR    x x | | | d | | | | | |         i: +
                rol     x,w             'ROL    x x | | | | e | | | | |         j: -
                add     x,w             '+      x x | | | | | | | | i |
                sub     x,w             '-      x x | | | | | | | | | j
                alti    wr              'wr     m n | | | | | | | | | |
                ret                     'wr,op  m n a b c d e f g h i j         m: var ?= exp   (isolated)
        _ret_   popa    x               'iso    m |                             n: var ?= exp   (push)
        _ret_   zerox   x,sz            'push     n                             x: use a..j
'
'
' Variable assignments / math operators (19 longs)
'
add_mod         and     x,#$1F          'addpb                      i j         a: &&
                shl     x,#5            'addb                       i |         b: ^^
                shl     x,#6            'addp                       | j         c: ||
log_mod         mov     w,x     wz      '       x x a b c d e f g h i j         d: &
                muxnz   w,_FFFFFFFF     'bool   x x a b c | | | | | | |         e: ^
                alti    rd              'rd     m n | | | | | | | | | |         f: |
                popa    x       wz      'rd,op  m n a b c d e f g h i j         g: #>
                muxnz   x,_FFFFFFFF     'bool   x x a b c | | | | | | |         h: <#
                and     x,w             '&&,&   x x a | | d | | | | | |         i: ADDBITS
                xor     x,w             '^^,^   x x | b | | e | | | | |         j: ADDPINS
                and     x,#$1F          'addb   x x | | | | | | | | i |
                and     x,#$3F          'addp   x x | | | | | | | | | j
                or      x,w             '||,|   x x | | c | | f | | i j
                fges    x,w             '#>     x x | | | | | | g | | |
                fles    x,w             '<#     x x | | | | | | | h | |
                alti    wr              'wr     m n | | | | | | | | | |
                ret                     'wr,op  m n a b c d e f g h i j         m: var ?= exp   (isolated)
        _ret_   popa    x               'iso    m |                             n: var ?= exp   (push)
        _ret_   zerox   x,sz            'push     n                             x: use a..h
'
'
' Variable pre/post modifiers           (28 longs, must be in regs)
'
mod_iso         mov     w,x             'iso    a b         g   i   k l         a: ++var, var++ (isolated)
mod_psh         pusha   x               'push   | | c d e f | h | j | | m       b: --var, var-- (isolated)
                alti    rd              'rd     a b c d e f g h i j k l m       c: ++var        (push)
rd_field        call    #\rdf           'rd     a b c d e f g h i j k l m       d: --var        (push)          (pipeline spacer)
                xoro32  x               '??     | | | | | | | | | | | l m       e: var++        (push)
                mov     v,x             'post   | | | | e f | h | j k l m       f: var--        (push)
                add     x,#1            '++     a | c | e | | | | | | | |       g: var!!        (isolated)
repvarin        sub     x,#1            '--     | b | d | f | | | | | | |  n    h: var!!        (push)
                zerox   x,sz            'ptr    | | c d | | | | | | | | |  |    i: var!         (isolated)
                pusha   x               '0..n-1 | | | | | | | | | | | | |  n    j: var!         (push)
                muxz    x,_FFFFFFFF     '!!     | | | | | | g h | | | | |  n    k: var\new      (swap)
                not     x               '!      | | | | | | | | i j | | |  |    l: ??var        (isolated)
                mov     x,w             'swap   | | | | | | | | | | k | |  |    m: ??var        (push)
                alti    wr              'wr     a b c d e f g h i j k l m  |
wr_field        call    #\wrf           'wr     a b c d e f g h i j k l m  |                                    (pipeline spacer)
        _ret_   mov     x,w             'iso    a b | | | | g | i | | l |  |
        _ret_   mov     x,v             'iso        | | e f   h   j k   m  |
                ret                     'main       c d                    |    n: REPEAT-var init, 0..n-1      (followed by repvari1)
'
'
' REPEAT-var init                       (must be in regs)
'
'  x            initial
'  ptra[-1]     delta
'  ptra[-2]     terminal
'  ptra[-3]     address
'
repvari1        pusha   #1              'set step to 1 (insert between terminal and initial)

repvari         alti    wr              'write variable
_FFFFFFFF       long    $FFFFFFFF       '(pipeline spacer)

                setq    #2-1            'pop terminal/delta into y/z
                rdlong  y,--ptra

                add     ptra,#2*4       'repoint to top of stack

                cmps    y,x     wc      'sign-correct delta
                abs     z
        if_c    neg     z
        _ret_   wrlong  z,ptra[-1]
'
'
' REPEAT-var loop                       (11 longs, must be in regs)
'
'  x            current (was initial)
'  ptra[-1]     delta
'  ptra[-2]     terminal
'  ptra[-3]     address
'
repvarl         setq    #3-1            'pop address/terminal/delta into a/b/c
                rdlong  a,--ptra

                add     x,c             'add delta into current

                alti    wr              'write variable
dcall           long    0               '(pipeline spacer)

                testb   c,#31   wz      'check for out-of-bounds
        if_nz   cmps    b,x     wc
        if_z    cmps    x,b     wc

        if_nc   add     ptra,#3*4       'if not out-of-bounds, unpop data and loop
        if_nc   jmp     #absjmp

        _ret_   popa    x               'out-of-bounds, pop stack, continue
'
'
' PINW(pins,val)                        (9 longs, must be in regs)
'
pinw_           ror     y,#6    wc      'y=pins, w=val (begins at pop2 in LUT)
                bitc    pinw_reg,#9     'select outa/outb for writing

                bmask   v,y             'make mask
                rol     y,#6

                rol     v,y             'justify mask
                rol     w,y             'justify val

                setq    v               'mux val into outa/outb using mask
pinw_reg        muxq    outa,w

        _ret_   dirh    y               'enable outputs
'
'
' Read bitfield                         (3 longs, must be in regs)
'
rdf             long    @lut_code       'read variable into x (rewritten)

                ror     x,fb            'lsb-justify bitfield

        _ret_   zerox   x,sz    wz      'trim it, affect z
'
'
' Write bitfield                        (12 longs, must be in regs)
'
wrf             mov     fd,x            'get bitfield data
                rol     fd,fb

                bmask   fm,sz           'make bitfield mask
                rol     fm,fb

                mov     fx,x            'preserve x
                rep     @stall,#1       'use REP to protect variable from interrupts
wrf_rd          push    #$1FF           'read variable into x (rewritten)       (initially: push $1FF, to begin xbyte on _ret_)
                setq    fm              'set bitfield mask                      (initially: no consequence)
                muxq    x,fd            'mux bitfield data into x               (initially: no consequence)
wrf_wr  _ret_   setq    #$1A1           'write x back to variable (rewritten)   (initially: begin xbyte, compress Ax..Fx, write flags)
stall   _ret_   mov     x,fx            'restore x
'
'
' Read/write instructions               (8 longs, must be in regs)
'
rd_byte         rdbyte  x,ad    wz      'all reads affect z
rd_word         rdword  x,ad    wz
rd_long         rdlong  x,ad    wz
rd_reg          mov     x,0     wz

wr_byte         wrbyte  x,ad
wr_word         wrword  x,ad
wr_long         wrlong  x,ad
wr_reg          mov     0,x
'
'
' End of cog register code
'
reg_end
'
'
' Interpreter registers
'
v               res     1               'v/pbase/vbase/dbase/mrecv/msend/w/x/y/z must remain in order
pbase           res     1
vbase           res     1
dbase           res     1
mrecv           res     1
msend           res     1
w               res     1
x               res     0
ma              res     1               '(x alias for float)
y               res     1
z               res     1
'
'
' PASM registers - 8 longs
'
pr0_            res     1               'pasm-use registers at $1D8
pr1_            res     1
pr2_            res     1
pr3_            res     1
pr4_            res     1
pr5_            res     1
pr6_            res     1
pr7_            res     1
'
'
' Buff registers - 16 longs
'
buff                                    'buff registers at $1E0

rd              res     1               'variable registers
wr              res     1
sz              res     1
ad              res     1

fd              res     1               'bitfield registers
fb              res     1
fm              res     1
fx              res     1

a               res     0               'a/b/c/d/e/f/g/h must remain in order
na              res     1               '(a alias for float)
b               res     0
sa              res     1               '(b alias for float)
c               res     0
xa              res     1               '(c alias for float)
d               res     0
mb              res     1               '(d alias for float)
e               res     0
nb              res     1               '(e alias for float)
f               res     0
sb              res     1               '(f alias for float)
g               res     0
xb              res     1               '(g alias for float)
h               res     1

                fit     $1F0            'buff occupies $1E0..$1EF, adjust user area size to fit
'
'
'***************************
'*  Interpreter - cog LUT  *
'***************************
'
                org     $210            'leave $20x open for 16 streamer imm->LUT->DAC/pin values
lut_code
'
'
' Drop anchor                           (8 longs)
'
'            dcall --> next_dbase[-1]   (push)
'       next_dbase --> dcall
'
'
'  ptr[+0] <-- v := x                   (current top of stack)
'  ptr[+1] <-- pbase | flags            (trap_flag into bit 1, push_flag into bit 0)
'  ptr[+2] <-- vbase
'  ptr[+3] <-- dbase
'  ptr[+4] <-- mrecv
'  ptr[+5] <-- msend
'  ptr += 6                             (point to new top of stack)
'  x (tos) <-- dcall                    (top of stack = dcall)
'  dcall = ptr + 1*4                    (set new dcall)
'
drop            or      pbase,pa        'get trap_flag into bit 1, get push_flag into bit 0

drophot         mov     v,x             'get top of stack into v

                setq    #6-1            'push v/pbase/vbase/dbase/mrecv/msend
                wrlong  v,ptra++        'ptra points to dcall in stack

                mov     x,dcall         'get dcall (prior dbase) into top of stack

                mov     dcall,ptra      'update dcall (next dbase)
                add     dcall,#1*4

        _ret_   andn    pbase,#%11      'clear bits 1..0 in pbase
'
'
' Call method / Make method pointer     (14 longs)
'
'           dcall --> dbase             (pop)
'       dbase[-1] --> dcall
'         retaddr --> dbase[-1]
'
'
callobj         rfvar   w               'a b         g   i j    get obj into w
callsub         rfvar   v               'a b c       |   i j k  get sub into v
                getptr  pb              'a b c       g   i j k  get updated ptr
                jmp     #callh          'a b |       |   i j k  continue in hub
                jmp     #callsubh       '    c       |          continue in hub ('call sub' is optimized)
callptr         jmp     #callptrh       '      d     |          continue in hub
callrecv        jmp     #callrecvh      '        e   |          continue in hub
callsend        jmp     #callsendh      '          f |          continue in hub
                jmp     #callsendbh     '            g          continue in hub

callgo          rdfast  #0,x            'a b c d e f g h        return from hub, start new bytecode read
                rfvar   x               'a b c d e f g h        get number of local longs
        _ret_   djnf    x,#.clear       'a b c d e f g h        if zero, continue
.clear          setq    x               'a b c d e f g h        else, clear locals and point stack past them
        _ret_   wrlong  #0,ptra++       'a b c d e f g h
'
'
' Setup reg variable                    (11 longs)
'
reg_im          signx   pa,#3           'a              a: setup reg[$1D8..$1DF]/[$1F8..$1FF]
                or      pa,#$1D8        'a              b: setup reg[rfvars]
                                        '               c: setup reg[rfvars][index]
reg_ap          rfvars  pa              '| b c
                add     pa,x            '| | c
                popa    x               '| | c

                mov     rd,rd_reg       'a b c
                mov     wr,wr_reg       'a b c

                sets    rd,pa           'a b c
                setd    wr,pa           'a b c

                mov     sz,#31          'a b c

        _ret_   setq2   #$0E1           'a b c          (next bytecode is a variable operator)
'
'
' Setup hub variable                    (22 longs)
'
hub_im          getnib  ad,pa,#0        'a b                                                    a: setup long[vbase][0..15]
hub_ap          rfvar   ad              '| | c d e f g h i j k l m n o p q r s t                b: setup long[dbase][0..15]
hub_pp          popa    ad              '| | | | | | | | | | | | | | | | | | | | u v w          c: setup byte[pbase + rfvar]
                                        '                                                       d: setup byte[vbase + rfvar]
                shl     x,#2            '| | | | | | | | | | | | | | | | | r s t | | w          e: setup byte[dbase + rfvar]
                shl     x,#1            '| | | | | | | | | | | l m n | | | | | | | v |          f: setup byte[pbase + rfvar][pop index]
                add     ad,x            '| | | | | f g h | | | l m n | | | r s t u v w          g: setup byte[vbase + rfvar][pop index]
                shl     ad,#2           'a b | | | | | | | | | | | | | | | | | | | | |          h: setup byte[dbase + rfvar][pop index]
                                        '                                                       i: setup word[pbase + rfvar]
                add     ad,pbase        '| | c | | f | | i | | l | | o | | r | | | | |          j: setup word[vbase + rfvar]
                add     ad,vbase        'a | | d | | g | | j | | m | | p | | s | | | |          k: setup word[dbase + rfvar]
                add     ad,dbase        '| b | | e | | h | | k | | n | | q | | t | | |          l: setup word[pbase + rfvar][pop index]
                                        '                                                       m: setup word[vbase + rfvar][pop index]
hub_p           mov     ad,x            '| | | | | | | | | | | | | | | | | | | | | | | x y z    n: setup word[dbase + rfvar][pop index]
                popa    x               '| | | | | f g h | | | l m n | | | r s t u v w x y z    o: setup long[pbase + rfvar]
                                        '                                                       p: setup long[vbase + rfvar]
                mov     rd,rd_byte      '| | c d e f g h | | | | | | | | | | | | u | | x | |    q: setup long[dbase + rfvar]
                mov     rd,rd_word      '| | | | | | | | i j k l m n | | | | | | | v | | y |    r: setup long[pbase + rfvar][pop index]
                mov     rd,rd_long      'a b | | | | | | | | | | | | o p q r s t | | w | | z    s: setup long[vbase + rfvar][pop index]
                                        '                                                       t: setup long[dbase + rfvar][pop index]
                mov     wr,wr_byte      '| | c d e f g h | | | | | | | | | | | | u | | x | |    u: setup byte[pop base][pop index]
                mov     wr,wr_word      '| | | | | | | | i j k l m n | | | | | | | v | | y |    v: setup word[pop base][pop index]
                mov     wr,wr_long      'a b | | | | | | | | | | | | o p q r s t | | w | | z    w: setup long[pop base][pop index]
                                        '                                                       x: setup byte[pop address]
                mov     sz,#7           '| | c d e f g h | | | | | | | | | | | | u | | x | |    y: setup word[pop address]
                mov     sz,#15          '| | | | | | | | i j k l m n | | | | | | | v | | y |    z: setup long[pop address]
                mov     sz,#31          'a b | | | | | | | | | | | | o p q r s t | | w | | z

        _ret_   setq2   #$0E1           'a b c d e f g h i j k l m n o p q r s t u v w x y z    (next bytecode is a variable operator)
'
'
' Setup bitfield                        (13 longs)
'
bit_im          mov     fb,pa           'a              a: setup bitfield [0..31]
                and     fb,#$1F         'a              b: setup bitfield [rfvar]
                                        '               c: setup bitfield [pop]
bit_rf          rfvar   fb              '| b

bit_p           mov     fb,x            '| | c
                popa    x               '| | c

                mov     sz,fb           'a b c
                shr     sz,#5           'a b c

                mov     rdf,rd          'a b c
                mov     wrf_rd,rd       'a b c
                mov     wrf_wr,wr       'a b c

                mov     rd,rd_field     'a b c
                mov     wr,wr_field     'a b c

        _ret_   setq2   #$0E1           'a b c          (next bytecode is a variable operator)
'
'
' Variable read/write                   (10 longs)
'
var_rd          pusha   x               'a   c          a: read  long[dbase][0..15]
                                        '               b: write long[dbase][0..15]     (isolated)
var_wr_im       getnib  ad,pa,#0        'a b |          c: read var
                shl     ad,#2           'a b |          d: write var                    (isolated)
                add     ad,dbase        'a b |          e: write var                    (push)

                alti    rd              '| | c
        _ret_   rdlong  x,ad            'a | c

var_wr          alti    wr              '  | | d e
                wrlong  x,ad            '  b | d e

        _ret_   popa    x               '  b | d |
        _ret_   zerox   x,sz            '    c   e      (ret for c, ret+zerox for e)
'
'
' Variable assignments / math operators (27 longs)
'
mul_mod         abs     w,x     wc      'C=ys   x x   b   d     g               a: *
muu_mod         mov     w,x             '       x x a | c | e f | h             b: /
                alti    rd              'rd     m n | | | | | | | |             c: +/
                popa    x               'rd,op  m n a b c d e f g h             d: //
                testb   x,#31   wz      'Z=xs   x x | b | d | | g |             e: +//
                abs     x               '       x x | b | d | | g |             f: SCA
                rep     #99,#1          '       x x a b c d e f g h             g: SCAS         use REP to protect cordic operation until call/ret/_ret_
                qmul    x,w             '*,SCAx x x a | | | | f g |             h: FRAC
                qdiv    x,w             '/,//   x x | b c d e | | |
                qfrac   x,w             'FRAC   x x | | | | | | | h
                getqx   x               '       x x a b c | | | | h
    if_c_ne_z   neg     x               '*,/    x x | b | | | | | |
                getqy   x               '       x x | | | d e f g |
    if_z        neg     x               '//     x x | | | d | | | |
                getqx   w               'SCAS   x x | | | | | | g |
                call    #\.scas         'SCAS   x x | | | | | | g |
                alti    wr              'wr     m n | | | | | | | |
                ret                     'wr,op  m n a b c d e f g h             m: var ?= exp   (isolated)
        _ret_   popa    x               'iso    m |                             n: var ?= exp   (push)
        _ret_   zerox   x,sz            'push     n                             x: use a..h

.scas if_c_eq_z jmp     #.scas2         'adjust 64-bit product for SCAS
                neg     w       wz      'conditionally negate {x,w}
    if_nz       not     x
    if_z        neg     x
.scas2          shl     x,#2            'x = {x,w}[61:30]
                shr     w,#32-2
        _ret_   or      x,w
'
'
' Add pbase to x                        (1 long)
'
addbase _ret_   add     x,pbase
'
'
' Variable operator bytecodes at $27A - triggered via '_ret_ setq2 #$0E1'
'
altcodes
                orgf    $27A

bc_repeat_var_init_n    long  repvarin  |          %011111110010 << 10  '7A Z=0 REPEAT-var init, 0..n-1
bc_repeat_var_init_1    long  repvari1  |                     %0 << 10  '7B     REPEAT-var init, step 1
bc_repeat_var_init      long  repvari   |                     %0 << 10  '7C     REPEAT-var init
bc_repeat_var_loop      long  repvarl   |                     %0 << 10  '7D     REPEAT-var loop

bc_get_field            long  var_ptr   |                    %00 << 10  '7E     ^@anyvar
bc_get_addr             long  var_ptr   |                  %0010 << 10  '7F     @hubvar
bc_read                 long  var_rd    |            %0111001110 << 10  '80     read var
bc_write                long  var_wr    |                     %0 << 10  '81     write var       (isolated)
bc_write_push           long  var_wr    |                  %0100 << 10  '82     write var       (push)

bc_var_inc              long  mod_iso   |      %0001111110110010 << 10  '83     ++var, var++    (isolated)
bc_var_dec              long  mod_iso   |      %0001111101110010 << 10  '84     --var, var--    (isolated)
bc_var_preinc_push      long  mod_psh   |    %01100111101011000_ << 10  '85     ++var           (push)
bc_var_predec_push      long  mod_psh   |    %01100111100111000_ << 10  '86     --var           (push)
bc_var_postinc_push     long  mod_psh   |     %0100111111001000_ << 10  '87     var++           (push)
bc_var_postdec_push     long  mod_psh   |     %0100111110101000_ << 10  '88     var--           (push)
bc_var_lognot           long  mod_iso   |      %0001101111110010 << 10  '89     var!!           (isolated)
bc_var_lognot_push      long  mod_psh   |     %0100110111101000_ << 10  '8A     var!!           (push)
bc_var_bitnot           long  mod_iso   |      %0001011111110010 << 10  '8B     var!            (isolated)
bc_var_bitnot_push      long  mod_psh   |     %0100101111101000_ << 10  '8C     var!            (push)
bc_var_swap             long  mod_iso   |     %01000111111010010 << 10  '8D     var\new         (swap)
bc_var_rnd              long  mod_iso   |      %0001111111000010 << 10  '8E     ??var           (isolated)
bc_var_rnd_push         long  mod_psh   |     %0100111111100000_ << 10  '8F     ??var           (push)

bc_lognot_write         long  una_iso   |  %00011111111011110010 << 10  '90     !!= var         (isolated)
bc_bitnot_write         long  una_iso   |  %00011111110111110010 << 10  '91     != var          (isolated)
bc_neg_write            long  una_iso   |  %00011111101111110010 << 10  '92     -= var          (isolated)
bc_abs_write            long  una_iso   |  %00011111011111110010 << 10  '93     ABS= var        (isolated)
bc_encod_write          long  una_iso   |  %00011110111111110010 << 10  '94     ENCOD= var      (isolated)
bc_decod_write          long  una_iso   |  %00011101111111110010 << 10  '95     DECOD= var      (isolated)
bc_bmask_write          long  una_iso   |  %00011011111111110010 << 10  '96     BMASK= var      (isolated)
bc_ones_write           long  una_iso   |  %00010111111111110010 << 10  '97     ONES= var       (isolated)
bc_sqrt_write           long  una_iso   |  %00001111111111000010 << 10  '98     SQRT= var       (isolated)
bc_qlog_write           long  una_iso   |  %00001111111110100010 << 10  '99     QLOG= var       (isolated)
bc_qexp_write           long  una_iso   |  %00001111111101100010 << 10  '9A     QEXP= var       (isolated)

bc_shr_write            long  sha_mod   |       %000111110110010 << 10  '9B     var >>= exp     (isolated)
bc_shl_write            long  sha_mod   |       %000111111010010 << 10  '9C     var <<= exp     (isolated)
bc_sar_write            long  sha_mod   |       %000111101110010 << 10  '9D     var SAR= exp    (isolated)
bc_ror_write            long  sha_mod   |       %000111011110010 << 10  '9E     var ROR= exp    (isolated)
bc_rol_write            long  sha_mod   |       %000110111110010 << 10  '9F     var ROL= exp    (isolated)
bc_rev_write            long  rev_mod   |       %00011111010000_ << 10  'A0     var REV= exp    (isolated)
bc_zerox_write          long  rev_mod   |       %00011111001000_ << 10  'A1     var ZEROX= exp  (isolated)
bc_signx_write          long  rev_mod   |       %00011110101000_ << 10  'A2     var SIGNX= exp  (isolated)
bc_add_write            long  sha_mod   |       %000101111110010 << 10  'A3     var += exp      (isolated)
bc_sub_write            long  sha_mod   |       %000011111110010 << 10  'A4     var -= exp      (isolated)

bc_logand_write         long  log_mod   |    %000111111000000___ << 10  'A5     var &&= exp     (isolated)
bc_logxor_write         long  log_mod   |    %000111110100000___ << 10  'A6     var ^^= exp     (isolated)
bc_logor_write          long  log_mod   |    %000110111100000___ << 10  'A7     var ||= exp     (isolated)
bc_bitand_write         long  log_mod   |    %000111111010010___ << 10  'A8     var &= exp      (isolated)
bc_bitxor_write         long  log_mod   |    %000111110110010___ << 10  'A9     var ^= exp      (isolated)
bc_bitor_write          long  log_mod   |    %000110111110010___ << 10  'AA     var |= exp      (isolated)
bc_fge_write            long  log_mod   |    %000101111110010___ << 10  'AB     var #>= exp     (isolated)
bc_fle_write            long  log_mod   |    %000011111110010___ << 10  'AC     var <#= exp     (isolated)
bc_addbits_write        long  add_mod   |    %000110101110010100 << 10  'AD     var ADDBITS exp (isolated)
bc_addpins_write        long  add_mod   |    %000110011110010010 << 10  'AE     var ADDPINS exp (isolated)

bc_mul_write            long  muu_mod   |   %000111110110011000_ << 10  'AF     var *= exp      (isolated)
bc_div_write            long  mul_mod   |   %0001111001010000010 << 10  'B0     var /= exp      (isolated)
bc_divu_write           long  muu_mod   |   %000111110101011000_ << 10  'B1     var +/= exp     (isolated)
bc_rem_write            long  mul_mod   |   %0001100111010000010 << 10  'B2     var //= exp     (isolated)
bc_remu_write           long  muu_mod   |   %000111011101011000_ << 10  'B3     var +//= exp    (isolated)
bc_sca_write            long  muu_mod   |   %000111011110011000_ << 10  'B4     var SCA= exp    (isolated)
bc_scas_write           long  mul_mod   |   %0000010111100000010 << 10  'B5     var SCAS= exp   (isolated)
bc_frac_write           long  muu_mod   |   %000111110011011000_ << 10  'B6     var FRAC= exp   (isolated)

bc_lognot_write_push    long  una_psh   |  %01001111111101111000 << 10  'B7     !!= var         (push)
bc_bitnot_write_push    long  una_psh   |  %01001111111011111000 << 10  'B8     != var          (push)
bc_neg_write_push       long  una_psh   |  %01001111110111111000 << 10  'B9     -= var          (push)
bc_abs_write_push       long  una_psh   |  %01001111101111111000 << 10  'BA     ABS= var        (push)
bc_encod_write_push     long  una_psh   |  %01001111011111111000 << 10  'BB     ENCOD= var      (push)
bc_decod_write_push     long  una_psh   |  %01001110111111111000 << 10  'BC     DECOD= var      (push)
bc_bmask_write_push     long  una_psh   |  %01001101111111111000 << 10  'BD     BMASK= var      (push)
bc_ones_write_push      long  una_psh   |  %01001011111111111000 << 10  'BE     ONES= var       (push)
bc_sqrt_write_push      long  una_psh   |  %01000111111111100000 << 10  'BF     SQRT= var       (push)
bc_qlog_write_push      long  una_psh   |  %01000111111111010000 << 10  'C0     QLOG= var       (push)
bc_qexp_write_push      long  una_psh   |  %01000111111110110000 << 10  'C1     QEXP= var       (push)

bc_shr_write_push       long  sha_mod   |      %0100111110110010 << 10  'C2     var >>= exp     (push)
bc_shl_write_push       long  sha_mod   |      %0100111111010010 << 10  'C3     var <<= exp     (push)
bc_sar_write_push       long  sha_mod   |      %0100111101110010 << 10  'C4     var SAR= exp    (push)
bc_ror_write_push       long  sha_mod   |      %0100111011110010 << 10  'C5     var ROR= exp    (push)
bc_rol_write_push       long  sha_mod   |      %0100110111110010 << 10  'C6     var ROL= exp    (push)
bc_rev_write_push       long  rev_mod   |      %010011111010000_ << 10  'C7     var REV= exp    (push)
bc_zerox_write_push     long  rev_mod   |      %010011111001000_ << 10  'C8     var ZEROX= exp  (push)
bc_signx_write_push     long  rev_mod   |      %010011110101000_ << 10  'C9     var SIGNX= exp  (push)
bc_add_write_push       long  sha_mod   |      %0100101111110010 << 10  'CA     var += exp      (push)
bc_sub_write_push       long  sha_mod   |      %0100011111110010 << 10  'CB     var -= exp      (push)

bc_logand_write_push    long  log_mod   |   %0100111111000000___ << 10  'CC     var &&= exp     (push)
bc_logxor_write_push    long  log_mod   |   %0100111110100000___ << 10  'CD     var ^^= exp     (push)
bc_logor_write_push     long  log_mod   |   %0100110111100000___ << 10  'CE     var ||= exp     (push)
bc_bitand_write_push    long  log_mod   |   %0100111111010010___ << 10  'CF     var &= exp      (push)
bc_bitxor_write_push    long  log_mod   |   %0100111110110010___ << 10  'D0     var ^= exp      (push)
bc_bitor_write_push     long  log_mod   |   %0100110111110010___ << 10  'D1     var |= exp      (push)
bc_fge_write_push       long  log_mod   |   %0100101111110010___ << 10  'D2     var #>= exp     (push)
bc_fle_write_push       long  log_mod   |   %0100011111110010___ << 10  'D3     var <#= exp     (push)
bc_addbits_write_push   long  add_mod   |   %0100110101110010100 << 10  'D4     var ADDBITS exp (push)
bc_addpins_write_push   long  add_mod   |   %0100110011110010010 << 10  'D5     var ADDPINS exp (push)

bc_mul_write_push       long  muu_mod   |  %0100111110110011000_ << 10  'D6     var *= exp      (push)
bc_div_write_push       long  mul_mod   |  %01001111001010000010 << 10  'D7     var /= exp      (push)
bc_divu_write_push      long  muu_mod   |  %0100111110101011000_ << 10  'D8     var +/= exp     (push)
bc_rem_write_push       long  mul_mod   |  %01001100111010000010 << 10  'D9     var //= exp     (push)
bc_remu_write_push      long  muu_mod   |  %0100111011101011000_ << 10  'DA     var +//= exp    (push)
bc_sca_write_push       long  muu_mod   |  %0100111011110011000_ << 10  'DB     var SCA= exp    (push)
bc_scas_write_push      long  mul_mod   |  %01000010111100000010 << 10  'DC     var SCAS= exp   (push)
bc_frac_write_push      long  muu_mod   |  %0100111110011011000_ << 10  'DD     var FRAC= exp   (push)

bc_setup_bfield_pop     long  bit_p     |                     %0 << 10  'DE *   setup bitfield .[pop]
bc_setup_bfield_rfvar   long  bit_rf    |                  %0110 << 10  'DF *   setup bitfield .[rfvar]

'bytecodes Ex/Fx are collapsed at runtime to LUT entries E0/E1

bc_setup_bfield_0_31    long  bit_im    |                %011100 << 10  'Ex *   setup bitfield .[0..15]
                        long  bit_im    |                %011100 << 10  'Fx *   setup bitfield .[16..31]
'
'
' a: PINR(pins)                         (14 longs)
'
pinr_           testb   x,#5    wc      'a      read ina or inb
        if_nc   mov     a,ina           'a
        if_c    mov     a,inb           'a
                ror     a,x             'a      lsb-justify
                shr     x,#6            'a      trim
                zerox   a,x             'a              (continued in pins_)
'
'
' PINSTART(pins,mode,xval,yval)
'
pins_           setq    #4-1            '|      pop parameters, including new top of stack
                rdlong  a,--ptra        '|      a=top of stack, b=pins, c=mode, d=xval, x=yval
                fltl    b               '|      reset smart pin(s)
                wrpin   c,b             '|      set smart pin(s) mode
                wxpin   d,b             '|      set smart pin(s) x
                wypin   x,b             '|      set smart pin(s) y
                drvl    b               '|      enable smart pin(s)
        _ret_   mov     x,a             'a      set top of stack
'
'
' a: POLLCT(tick)                       (16 longs)
' b: LOOKUP/LOOKDOWN done
' n: WAITCT(tick)
'
pwct            getct   w               'a   n          a: POLLCT(tick)
                cmpm    w,x     wc      'a   n          n: WAITCT(tick)
        if_c    jmp     #pwct           '|   n
        _ret_   popa    x               '|   n
lookd           sub     ptra,#2*4       '| b            (continued in op_rel)
'
'
' Relational operators
'
op_rel          popa    w               '| | c d e f g h i j k l m      c: <
                cmps    w,x     wcz     '| | c | | | g h i | | | m      d: +<
                cmps    x,w     wcz     '| | | | e | | | | | k | |      e: <=
                cmp     w,x     wcz     '| | | d | | | | | j | | |      f: +<=
                cmp     x,w     wcz     '| | | | | f | | | | | l |      g: ==
        _ret_   muxnc   x,_FFFFFFFF     'a b | | e f | | i j | | |      h: <>
        _ret_   muxc    x,_FFFFFFFF     '    c d     | |     k l |      i: >=
        _ret_   muxnz   x,_FFFFFFFF     '            | h         |      j: +>=
        _ret_   muxz    x,_FFFFFFFF     '            g           |      k: >
                muxc    x,_FFFFFFFF     '                        m      l: +>
        _ret_   muxnz   x,#1            '                        m      m: <=>
'
'
' Main bytecodes at $300
'
maincodes
                orgf    $300

bc_drop                 long  drop      |                     %0 << 10  '00     drop anchor     (0..3)
bc_drop_push            long  drop      |                     %0 << 10  '01     drop anchor, push
bc_drop_trap            long  drop      |                     %0 << 10  '02     drop anchor, trap
bc_drop_trap_push       long  drop      |                     %0 << 10  '03     drop anchor, trap, push

bc_return_results       long  return_   |                     %0 << 10  '04 Z=0 RETURN
bc_return_args          long  return_   |                     %0 << 10  '05 Z=1 RETURN x,y,z...

bc_abort_0              long  abort_    |                     %0 << 10  '06 Z=0 ABORT
bc_abort_arg            long  abort_    |                     %0 << 10  '07 Z=1 ABORT x

bc_call_obj_sub         long  callobj   |         %01000010_0000 << 10  '08     call obj.sub
bc_call_obji_sub        long  callobj   |      %01001000000_0000 << 10  '09     call obj[].sub
bc_call_sub             long  callsub   |               %0_0100_ << 10  '0A     call sub
bc_call_ptr             long  callptr   |                     %0 << 10  '0B     call ptr()
bc_call_recv            long  callrecv  |                     %0 << 10  '0C     call RECV()
bc_call_send            long  callsend  |                     %0 << 10  '0D     call SEND(x)
bc_call_send_bytes      long  callobj   |             %011111010 << 10  '0E     call SEND(bytes...)

bc_mptr_obj_sub         long  callobj   |    %01100_0000010_0000 << 10  '0F     @obj.sub        (push)
bc_mptr_obji_sub        long  callobj   |    %01110_0000000_0000 << 10  '10     @obj[].sub      (push)
bc_mptr_sub             long  callsub   |          %0111110_000_ << 10  '11     @sub            (push)

bc_jmp                  long  branch    |         %0111101111110 << 10  '12     jmp  rfvars
bc_jz                   long  branch    |         %0111101110000 << 10  '13     jz   rfvars
bc_jnz                  long  branch    |         %0111100111000 << 10  '14     jnz  rfvars
bc_tjz                  long  branch    |         %0111101010100 << 10  '15     tjz  rfvars
bc_djnz                 long  branch    |         %0111100001110 << 10  '16     djnz rfvars

bc_pop                  long  pop1      |                     %0 << 10  '17     pop
bc_pop_rfvar            long  popx      |             %011111100 << 10  '18     pop rfvar

bc_hub_bytecode         long  hub_code  |                     %0 << 10  '19     hub bytecode rfbyte

bc_case_fast_init       long  casefi    |        %01010000000000 << 10  '1A     CASE_FAST init
bc_case_fast_done       long  casefd    |                     %0 << 10  '1B     CASE_FAST done

bc_case_value           long  casev     |                     %0 << 10  '1C     CASE value
bc_case_range           long  range     |         %0110110000000 << 10  '1D     CASE value1..value2
bc_case_done            long  cased     |                  %0000 << 10  '1E     CASE done

bc_lookup_value         long  lookv     |              %00001000 << 10  '1F C=1 LOOKUP  (target : ,,value,,)
bc_lookdown_value       long  lookv     |              %00000100 << 10  '20 C=0 LOOKDOWN(target : ,,value,,)
bc_lookup_range         long  range     |%1100111111000000111100 << 10  '21     LOOKUP  (target : ,,value1..value2,,)
bc_lookdown_range       long  range     |%0011110000110000011100 << 10  '22     LOOKDOWN(target : ,,value1..value2,,)
bc_look_done            long  lookd     |               %0111110 << 10  '23 C=1 LOOKUP/LOOKDOWN done

bc_add_pbase            long  addbase   |                     %0 << 10  '24     add pbase to x

bc_coginit              long  pop2      |     %01111100111111000 << 10  '25     COGINIT(cog,pgm,ptr)
bc_coginit_push         long  pop2      |          %000111111000 << 10  '26     COGINIT(cog,pgm,ptr)    (push)
bc_cogstop              long  cogstop_  |                 %01110 << 10  '27     COGSTOP(cog)
bc_cogid                long  pushv     |                 %01110 << 10  '28     COGID()         (push)

bc_locknew              long  pushv     |         %0111111011110 << 10  '29     LOCKNEW()       (push)
bc_lockret              long  lockret_  |                  %0110 << 10  '2A     LOCKRET(lock)
bc_locktry              long  locktry_  |                    %00 << 10  '2B     LOCKTRY(lock)   (push)
bc_lockrel              long  lockrel_  |                   %010 << 10  '2C     LOCKREL(lock)
bc_lockchk              long  lockchk_  |                  %0110 << 10  '2D     LOCKCHK(lock)   (push)

bc_cogatn               long  cogatn_   |                    %00 << 10  '2E     COGATN(mask)
bc_pollatn              long  pushv     |       %011111110111110 << 10  '2F     POLLATN()       (push)
bc_waitatn              long  waitatn_  |                   %000 << 10  '30     WAITATN()

bc_getrnd               long  pushv     |                   %010 << 10  '31     GETRND()        (push)
bc_getct                long  pushv     |                  %0110 << 10  '32     GETCT()         (push)
bc_pollct               long  pwct      |           %01111111100 << 10  '33     POLLCT(tick)    (push)
bc_waitct               long  pwct      |                     %0 << 10  '34     WAITCT(tick)

bc_pinwrite             long  pop2      |                %011000 << 10  '35     PINWRITE(pins,val)
bc_pinlow               long  pinl_     |               %0111110 << 10  '36     PINLOW(pins)
bc_pinhigh              long  pinh_     |                %011110 << 10  '37     PINHIGH(pins)
bc_pintoggle            long  pint_     |                 %01110 << 10  '38     PINTOGGLE(pins)
bc_pinfloat             long  pinf_     |                  %0110 << 10  '39     PINFLOAT(pins)
bc_pinread              long  pinr_     |        %01111111000000 << 10  '3A     PINREAD(pins)   (push)

bc_pinstart             long  pins_     |                     %0 << 10  '3B     PINSTART(pins,mode,xval,yval)
bc_pinclear             long  pinf_     |                  %0100 << 10  '3C     PINCLEAR(pins)

bc_wrpin                long  pop2      |               %0111000 << 10  '3D     WRPIN(pins,val)
bc_wxpin                long  pop2      |              %01111000 << 10  '3E     WXPIN(pins,val)
bc_wypin                long  pop2      |             %011111000 << 10  '3F     WYPIN(pins,val)
bc_akpin                long  akpin_    |                    %00 << 10  '40     AKPIN(pins)
bc_rdpin                long  rdpin_    |                   %010 << 10  '41     RDPIN(pin)      (push)
bc_rqpin                long  rqpin_    |                    %00 << 10  '42     RQPIN(pin)      (push)

bc_debug                long  debug_    |         %0001111111000 << 10  '43     DEBUG() rfvar,rfbyte

bc_con_rfbyte           long  const     |                  %0110 << 10  '44     constant rfbyte
bc_con_rfbyte_not       long  const     |         %0111111101110 << 10  '45     constant rfbyte!
bc_con_rfword           long  const     |                %011110 << 10  '46     constant rfword
bc_con_rfword_not       long  const     |         %0111110111110 << 10  '47     constant rfword!
bc_con_rflong           long  const     |              %01111110 << 10  '48     constant rflong
bc_con_rfbyte_decod     long  const     |             %011101110 << 10  '49     constant rfbyte + decod
bc_con_rfbyte_decod_not long  const     |         %0110111101110 << 10  '4A     constant rfbyte + decod + not
bc_con_rfbyte_bmask     long  const     |           %01111101110 << 10  '4B     constant rfbyte + bmask
bc_con_rfbyte_bmask_not long  const     |         %0011111101110 << 10  '4C     constant rfbyte + bmask + not

bc_setup_field_p        long  field_    |                     %0 << 10  '4D *   setup field[pop field]
bc_setup_field_pi       long  fieldi_   |                     %0 << 10  '4E *   setup field[pop field][pop index]

bc_setup_reg            long  reg_ap    |                  %0110 << 10  '4F *   setup reg[rfvars]
bc_setup_reg_pi         long  reg_ap    |                     %0 << 10  '50 *   setup reg[rfvars][pop index]

bc_setup_byte_pbase     long  hub_ap    | %011011011011110111110 << 10  '51 *   setup byte[pbase + rfvar]
bc_setup_byte_vbase     long  hub_ap    | %011011011011101111110 << 10  '52 *   setup byte[vbase + rfvar]
bc_setup_byte_dbase     long  hub_ap    | %011011011011011111110 << 10  '53 *   setup byte[dbase + rfvar]
bc_setup_byte_pbase_pi  long  hub_ap    | %011011011001110101110 << 10  '54 *   setup byte[pbase + rfvar][pop index]
bc_setup_byte_vbase_pi  long  hub_ap    | %011011011001101101110 << 10  '55 *   setup byte[vbase + rfvar][pop index]
bc_setup_byte_dbase_pi  long  hub_ap    | %011011011001011101110 << 10  '56 *   setup byte[dbase + rfvar][pop index]

bc_setup_word_pbase     long  hub_ap    | %010110110111110111110 << 10  '57 *   setup word[pbase + rfvar]
bc_setup_word_vbase     long  hub_ap    | %010110110111101111110 << 10  '58 *   setup word[vbase + rfvar]
bc_setup_word_dbase     long  hub_ap    | %010110110111011111110 << 10  '59 *   setup word[dbase + rfvar]
bc_setup_word_pbase_pi  long  hub_ap    | %010110110101110100110 << 10  '5A *   setup word[pbase + rfvar][pop index]
bc_setup_word_vbase_pi  long  hub_ap    | %010110110101101100110 << 10  '5B *   setup word[vbase + rfvar][pop index]
bc_setup_word_dbase_pi  long  hub_ap    | %010110110101011100110 << 10  '5C *   setup word[dbase + rfvar][pop index]

bc_setup_long_pbase     long  hub_ap    | %001101101111110111110 << 10  '5D *   setup long[pbase + rfvar]
bc_setup_long_vbase     long  hub_ap    | %001101101111101111110 << 10  '5E *   setup long[vbase + rfvar]
bc_setup_long_dbase     long  hub_ap    | %001101101111011111110 << 10  '5F *   setup long[dbase + rfvar]
bc_setup_long_pbase_pi  long  hub_ap    | %001101101101110101010 << 10  '60 *   setup long[pbase + rfvar][pop index]
bc_setup_long_vbase_pi  long  hub_ap    | %001101101101101101010 << 10  '61 *   setup long[vbase + rfvar][pop index]
bc_setup_long_dbase_pi  long  hub_ap    | %001101101101011101010 << 10  '62 *   setup long[dbase + rfvar][pop index]

bc_setup_byte_pb_pi     long  hub_pp    |  %01101101100111110110 << 10  '63 *   setup byte[pop base][pop index]
bc_setup_word_pb_pi     long  hub_pp    |  %01011011010111110010 << 10  '64 *   setup word[pop base][pop index]
bc_setup_long_pb_pi     long  hub_pp    |  %00110110110111110100 << 10  '65 *   setup long[pop base][pop index]

bc_setup_byte_pa        long  hub_p     |          %011011011000 << 10  '66 *   setup byte[pop address]
bc_setup_word_pa        long  hub_p     |          %010110110100 << 10  '67 *   setup word[pop address]
bc_setup_long_pa        long  hub_p     |          %001101101100 << 10  '68 *   setup long[pop address]

bc_unused1              long  0         |                     %0 << 10  '69
bc_unused2              long  0         |                     %0 << 10  '6A

bc_ternary              long  ternary   |                  %0000 << 10  '6B     x ? y : z

bc_lt                   long  op_rel    |               %0111100 << 10  '6C     exp <   exp
bc_ltu                  long  op_rel    |               %0110110 << 10  '6D     exp +<  exp
bc_lte                  long  op_rel    |                %011010 << 10  '6E     exp <=  exp
bc_lteu                 long  op_rel    |                %001110 << 10  '6F     exp +<= exp
bc_e                    long  op_rel    |             %011111100 << 10  '70     exp ==  exp
bc_ne                   long  op_rel    |              %01111100 << 10  '71     exp <>  exp
bc_gte                  long  op_rel    |                %011100 << 10  '72     exp >=  exp
bc_gteu                 long  op_rel    |                %010110 << 10  '73     exp +>= exp
bc_gt                   long  op_rel    |               %0111010 << 10  '74     exp >   exp
bc_gtu                  long  op_rel    |               %0101110 << 10  '75     exp +>  exp
bc_ltegt                long  op_rel    |           %00111111100 << 10  '76     exp <=> exp

bc_lognot               long  op_notb   |      %0111111111011110 << 10  '77     !!exp           (NOT exp)
bc_bitnot               long  op_not    |      %0111111110______ << 10  '78     !exp
bc_neg                  long  op_neg    |      %011111110_______ << 10  '79     -exp
bc_abs                  long  op_abs    |      %01111110________ << 10  '7A     ABS exp
bc_encod                long  op_encod  |      %0111110_________ << 10  '7B     ENCOD exp
bc_decod                long  op_decod  |      %011110__________ << 10  '7C     DECOD exp
bc_bmask                long  op_bmask  |      %01110___________ << 10  '7D     BMASK exp
bc_ones                 long  op_ones   |      %0110____________ << 10  '7E     ONES exp
bc_sqrt                 long  op_quna   |      %010111111111100_ << 10  '7F     SQRT exp
bc_qlog                 long  op_quna   |      %010111111111010_ << 10  '80     QLOG exp
bc_qexp                 long  op_quna   |      %010111111110110_ << 10  '81     QEXP exp

bc_shr                  long  sha_mod   |        %01111110110110 << 10  '82     exp >> exp
bc_shl                  long  sha_mod   |        %01111111010110 << 10  '83     exp << exp
bc_sar                  long  sha_mod   |        %01111101110110 << 10  '84     exp SAR exp
bc_ror                  long  sha_mod   |        %01111011110110 << 10  '85     exp ROR exp
bc_rol                  long  sha_mod   |        %01110111110110 << 10  '86     exp ROL exp
bc_rev                  long  rev_mod   |        %0111111010010_ << 10  '87     exp REV exp
bc_zerox                long  rev_mod   |        %0111111001010_ << 10  '88     exp ZEROX exp
bc_signx                long  rev_mod   |        %0111110101010_ << 10  '89     exp SIGNX exp
bc_add                  long  sha_mod   |        %01101111110110 << 10  '8A     exp + exp
bc_sub                  long  sha_mod   |        %01011111110110 << 10  '8B     exp - exp

bc_logand               long  log_mod   |     %01111111000100___ << 10  '8C     exp && exp      (exp AND exp)
bc_logxor               long  log_mod   |     %01111110100100___ << 10  '8D     exp ^^ exp      (exp XOR exp)
bc_logor                long  log_mod   |     %01110111100100___ << 10  '8E     exp || exp      (exp OR exp)
bc_bitand               long  log_mod   |     %01111111010110___ << 10  '8F     exp & exp
bc_bitxor               long  log_mod   |     %01111110110110___ << 10  '90     exp ^ exp
bc_bitor                long  log_mod   |     %01110111110110___ << 10  '91     exp | exp
bc_fge                  long  log_mod   |     %01101111110110___ << 10  '92     exp #> exp
bc_fle                  long  log_mod   |     %01011111110110___ << 10  '93     exp <# exp
bc_addbits              long  add_mod   |     %01110101110110100 << 10  '94     var ADDBITS exp
bc_addpins              long  add_mod   |     %01110011110110010 << 10  '95     var ADDPINS exp

bc_mul                  long  muu_mod   |    %01111110110011010_ << 10  '96     exp * exp
bc_div                  long  mul_mod   |    %011111001010000110 << 10  '97     exp / exp
bc_divu                 long  muu_mod   |    %01111110101011010_ << 10  '98     exp +/ exp
bc_rem                  long  mul_mod   |    %011100111010000110 << 10  '99     exp // exp
bc_remu                 long  muu_mod   |    %01111011101011010_ << 10  '9A     exp +// exp
bc_sca                  long  muu_mod   |    %01111011110011010_ << 10  '9B     exp SCA exp
bc_scas                 long  mul_mod   |    %010010111100000110 << 10  '9C     exp SCAS exp
bc_frac                 long  muu_mod   |    %01111110011011010_ << 10  '9D     exp FRAC exp

bc_string               long  string_   |    %011110111111100010 << 10  '9E     STRING()
bc_bitrange             long  bitrange  |                 %00110 << 10  '9F     bitrange

'bytecodes Ax/Bx/Cx/Dx/Ex/Fx are collapsed at runtime to LUT entries A0/A1/A2/A3/A4/A5

bc_con_n                long  const     |                   %000 << 10  'Ax     constant -1..14
bc_setup_reg_1D8_1F8_   long  reg_im    |                %011100 << 10  'Bx *   setup reg $1D8..$1DF/$1F8..$1FF
bc_setup_var_0_15_      long  hub_im    |  %11011011111010111110 << 10  'Cx *   setup long[vbase][0..15]
bc_setup_local_0_15_    long  hub_im    |  %11011011110110111110 << 10  'Dx *   setup long[dbase][0..15]
bc_read_local_0_15_     long  var_rd    |                %010000 << 10  'Ex     read  long[dbase][0..15]
bc_write_local_0_15_    long  var_wr_im |               %0111000 << 10  'Fx     write long[dbase][0..15]  (isolated)

                                        '* must end in '_ret_ setq2 #$0E1' to invoke variable operator bytecodes
'
'
' a: ^@anyvar                           (4 longs)
' b: @hubvar
'
var_ptr         pusha   x               'a b
                jmp     #mfieldh        'a |
                mov     x,ad            '  b
        _ret_   zerox   x,#19           '  b
'
'
' Constants                             (13 longs)
'
const           pusha   x               'a b c d e f g h i j    a: constant -1..14
                mov     x,pa            'a | | | | | | | | |    b: byte
        _ret_   sub     x,#bc_con_n-$2FF'a | | | | | | | | |    c: byte!
        _ret_   rfbyte  x               '  b | | | | | | | |    d: word
                rfbyte  x               '    c | | | g h i j    e: word!
        _ret_   rfword  x               '    | d | | | | | |    f: long
                rfword  x               '    |   e | | | | |    g: byte + decod
        _ret_   rflong  x               '    |   | f | | | |    h: byte + decod + not
        _ret_   decod   x               '    |   |   g | | |    i: byte + bmask
                decod   x               '    |   |     h | |    j: byte + bmask + not
        _ret_   bmask   x               '    |   |     | i |
                bmask   x               '    |   |     |   j
        _ret_   not     x               '    c   e     h   j
'
'
' Setup field variable                  (1 long)
'
field_          jmp     #fieldh         'continue in hub
'
'
' Setup field variable with index       (1 long)
'
fieldi_         jmp     #fieldih        'continue in hub
'
'
' Miscellaneous                         (19 longs)
'
ternary         setq    #2-1            'a                      a: ternary (y ? z : x)
bitrange        rdlong  y,--ptra        'a b                    b: bitrange (top,bottom --> bottom,top-bottom)
        _ret_   tjnz    y,#.true        'a |                    c: GETRND()
.true   _ret_   mov     x,z             'a |                    d: GETCT()
pushv           pusha   x               '  b c d e f g          e: COGID()
        _ret_   subr    x,y             '  b | | | | |          f: LOCKNEW()
        _ret_   getrnd  x               '    c | | | |          g: POLLATN()
        _ret_   getct   x               '      d | | |          h: WAITATN()
        _ret_   cogid   x               '        e | |          i: LOCKCHK(lock)
                locknew x       wc      '          f |          j: RDPIN(pin)
waitatn_        pollatn         wc      '          | g h        k: RQPIN(pin)
        if_nc   jmp     #waitatn_       '          | | h        l: LOCKTRY(lock)
                ret                     '          | | h
lockchk_        lockrel x       wc      '          | |   i
rdpin_          rdpin   x,x     wc      '          | |   | j
rqpin_          rqpin   x,x     wc      '          | |   | | k
        _ret_   bitc    x,#31           '          f |   i j k
locktry_        locktry x       wc      '            |         l
        _ret_   muxc    x,_FFFFFFFF     '            g         l
'
'
' Miscellaneous                         (5 longs)
'
                long    0[5]
'
'
' a: CASE_FAST init                     (4 longs)
'
' entry:
'
'   x           index
'   ptra[-1]    address
'
' exit:
'
'   x           address
'
'
' b: CASE_FAST done
'
' entry:
'
'   x           address
'
casefi          rflong  v               'a      get index base
                rfword  w               'a      get index limiter
                jmp     #casefih        'a      continue in hub

casefd          jmp     #casefdh        '  b    continue in hub
'
'
' CASE value                            (9 longs)
'
' entry:
'
'   x           value
'   ptra[-1]    target
'   ptra[-2]    address
'
' exit:
'
'   x           target
'   ptra[-1]    address
'
'
casev           rfvar   a               'read address

                mov     w,x             'value into w
                popa    x               'pop target into x
                sub     w,x     wz      'value = target?
        if_nz   ret                     'exit if not equal

reljmp          add     a,pb            'add relative address
        _ret_   rdfast  #0,a            'branch

absjmp          add     a,pbase         'add pbase
        _ret_   rdfast  #0,a            'branch to case code
'
'
' a: LOOKUP(target : ,,,value,,,)       C=1     (8 longs)
'
'  if index == target
'    result := value
'    branch to address
'  else index++
'
'
' b: LOOKDOWN(target : ,,,value,,,)     C=0
'
'  if value == target
'    result := index
'    branch to address
'  else index++
'
'
'  x            value           x
'  ptra[-1]     index           c
'  ptra[-2]     target          b
'  ptra[-3]     address         a
'
'
lookv           setq    #3-1            'a b    pop address/target/index into a/b/c
                rdlong  a,--ptra        'a b

                cmp     b,c     wz      'a |    index == target?
                cmp     b,x     wz      '| b    value == target?

  if_nc_or_nz   mov     x,c             'a b    if LOOKDOWN or not equal, get index on stack top

  if_z          jmp     #absjmp         'a b    if equal, branch to address

                add     ptra,#2*4       'a b    else, unpop address/target
  _ret_         add     x,#1            'a b    get index++ on stack top
'
'
' a: LOOKUP(target : ,,,value1..value2,,,)      (26 longs)
'
'  if value1 <= value2
'    delta = value2 - value1
'    if index <= target <= index + delta
'      result = value1 - index + target
'      branch to address
'    else index += delta + 1
'
'  if value1 > value2
'    delta = value1 - value2
'    if index <= target <= index + delta
'      result = value1 + index - target
'      branch to address
'    else index += delta + 1
'
' entry:
'
'  x            value2          x
'  ptra[-1]     value1          d
'  ptra[-2]     index           c
'  ptra[-3]     target          b
'  ptra[-4]     address         a
'
'
' b: LOOKDOWN(target : ,,,value1..value2,,,)
'
'  if value1 <= value2
'    delta = value2 - value1
'    if value1 <= target <= value2
'      result = - value1 + index + target
'      branch to address
'    else index += delta + 1
'
'  if value1 > value2
'    delta = value1 - value2
'    if value2 <= target <= value1
'      result = value1 + index - target
'      branch to address
'    else index += delta + 1
'
' entry:
'
'  x            value2          x
'  ptra[-1]     value1          d
'  ptra[-2]     index           c
'  ptra[-3]     target          b
'  ptra[-4]     address         a
'
'
' c: CASE value1..value2
'
' entry:
'
'   x           value2          x
'   ptra[-1]    value1          d
'   ptra[-2]    target          b
'   ptra[-3]    address         (ignored)
'
' exit:
'
'   x           target
'   ptra[-1]    address
'
'
range           setq    #4-1            'a b c          look: pop address/target/index/value1 into a/b/c/d
                rdlong  a,--ptra        'a b c          case: pop ?/address/target/value1 into a/b/c/d

                add     ptra,#2*4       '| | c          unpop ?/address
                rfvar   a               '| | c          read address into a
                mov     b,c             '| | c          get target into b

                mov     w,x             '| b c          copy value2 into w

                subs    x,d     wc      'a b c          c = (value1 > value2)
                negc    x               'a b |          x = delta
                add     x,c             'a b |          x = index + delta

                modz    _c      wz      'a b c          z = (value1 > value2)

                cmp     b,c     wc      'a | |          nc = (target >= index)
  if_nc         cmp     x,b     wc      'a | |          nc = (index + delta >= target)

  if_nz         cmps    b,d     wc      '| b c          if nz, nc = (value1 <= target <= value2)
  if_nz_and_nc  cmps    w,b     wc      '| b c
  if_z          cmps    b,w     wc      '| b c          if z, nc = (value2 <= target <= value1)
  if_z_and_nc   cmps    d,b     wc      '| b c

  if_nc         jmp     #reljmp         '| | c          if in range, branch to address
  _ret_         mov     x,c             '| | c          else, get target on top of stack

  if_nc         mov     x,d             'a |            if in range, get result in x
  if_nc         sumnz   x,c             'a |

  if_nc         mov     x,c             '| b            if in range, get result in x
  if_nc         sumnz   x,d             '| b

  if_nc         sumz    x,b             'a b
  if_nc         jmp     #absjmp         'a b            if in range, branch to address

                add     ptra,#2*4       'a b            else, unpop address/target
  _ret_         add     x,#1            'a b            x = index + delta + 1
'
'
' LOOKUP/LOOKDOWN done (code at lookd)
'
'
'  x            index
'  ptra[-1]     target
'  ptra[-2]     address
'
'
{
lookd           sub     ptra,#2*4       'pop target+address
        _ret_   mov     x,#0            'get zero on stack top
}
'
'
' CASE done (code at cased)
'
' entry:
'
'   x           target
'   ptra[-1]    address
'   ptra[-2]    new_x
'
' exit:
'
'   x           new_x
'   ptra[-1]
'
{
cased           setq    #2-1            'pop new_x/address into x/y
                rdlong  x,--ptra

                add     y,pbase         'branch to address
        _ret_   rdfast  #0,y
}
'
'
' End of cog LUT code
'
lut_end
'
'
'***********************
'*  Interpreter - hub  *
'***********************
'
                orgh
'
'
' RETURN                Z=0     - return results in stack
' RETURN x,y,z          Z=1     - return args on top of stack
'
'  ptra = dbase                         (point to current stack)
'  ptra[-7] --> v                       (top of caller stack)
'  ptra[-6] --> pbase | flags           (trap_flag in bit 1, push_flag in bit 0)
'  ptra[-5] --> vbase
'  ptra[-4] --> dbase                   (lower stack pointer)
'  ptra[-3] --> mrecv
'  ptra[-2] --> msend
'  ptra[-1] --> w                       (bytecode return pointer)
'  ptra -= 7                            (point to top of caller stack)
'
'  case {trap_flag, push_flag}
'    %00: restore caller stack
'    %01: return (Z ? stack_args : results)
'    %10: restore caller stack
'    %11: return 0
'
returnh if_z    mov     y,ptra          'if returning arg(s), save ptra (x holds last arg)
        if_nz   mov     y,dbase         'if returning result(s), save dbase

                mov     ptra,dbase      'ptra points to dbase

                setq    #7-1            'pop v/pbase/vbase/dbase/mrecv/msend/w
                rdlong  v,--ptra        'ptra points to caller's stack top after pop

                rczr    pbase      wcz  'save Z, get trap_flag into C and push_flag into Z
  if_c_and_z    add     ptra,#1*4       'if trap_flag and push_flag, return #0
  if_c_and_z    mov     v,#0
  if_c_or_nz    jmp     #.top           'if !push_flag, restore caller's stack top

                getnib  z,w,#5          'get return-value count and decrement
                djf     z,#.top         'if 0 return values, restore caller's stack top

                add     ptra,#1*4       '1..15 return values, inc past caller's stack top

                testb   pbase,#30  wz   'restore Z
        if_z    tjz     z,#.xok         'if returning 1 arg, ptra and x are already current
        if_z    neg     v,z             'if returning 2..15 args, get offset (-$01..-$0E)
        if_nz   getbyte v,w,#3          'if returning 1..15 results, get offset ($00..$7F)
                shl     v,#2            'scale offset
                add     y,v             'add offset

                setq    z               'read args/results into buff
                rdlong  buff,y

                setq    z               'write args/results into stack
                wrlong  buff,ptra++

                sub     ptra,#1*4       'set ptra to caller's new stack top

        if_z    skip    #%11            'if returning 2..15 args, x is already current
                alts    z,#buff         'set stack top to last result
.top            mov     x,v             'restore/update caller's stack top

.xok            shl     pbase,#2        'restore pbase, clearing two lsb's

        _ret_   rdfast  #0,w            'start new bytecode read
'
'
' ABORT                 Z=0     - returns 0
' ABORT x               Z=1     - returns arg on top of stack
'
'  repeat
'    ptra = dbase                       (point to current stack)
'    ptra[-7] --> v                     (top of caller stack)
'    ptra[-6] --> pbase | flags         (trap_flag in bit 1, push_flag in bit 0)
'    ptra[-5] --> vbase
'    ptra[-4] --> dbase                 (lower stack pointer)
'    ptra[-3] --> mrecv
'    ptra[-2] --> msend
'    ptra[-1] --> w                     (bytecode return pointer)
'    ptra -= 7                          (point to top of caller stack)
'  while !trap_flag
'
'  case {Z, push_flag}
'    %00: restore caller stack
'    %01: return 0
'    %10: restore caller stack
'    %11: return stack_arg
'
aborth          mov     ptra,dbase      'ptra points to dbase

                setq    #7-1            'pop v/pbase/vbase/dbase/mrecv/msend/w
                rdlong  v,--ptra        'ptra points to stack top after pop

                ror     pbase,#2  wc    'get trap_flag into c
  if_nc         jmp     #aborth         'if !trap_flag, pop again

                shl     pbase,#2  wc    'restore pbase, get push_flag into c
  if_nc         mov     x,v             'if !push_flag, restore top of caller stack into x
  if_c          add     ptra,#1*4       'if push_flag, inc ptr, x may already hold result
  if_c_and_nz   mov     x,#0            'if push_flag and !Z, return 0

        _ret_   rdfast  #0,w            'start new bytecode read
'
'
' Call method / Make method pointer
'
' operation             compile sequence...
' ---------------------------------------------------------------------------------------
' a: call obj.sub                       bc_call_obj_sub         rfvar obj       rfvar sub
' b: call obj[].sub     push obji       bc_call_obji_sub        rfvar obj       rfvar sub
' c: call sub                           bc_call_sub                             rfvar sub
' d: call ptr()         read var        bc_call_ptr
' e: call recv()                        bc_call_recv
' f: call send()        compile_exp     bc_call_send
' g: call sendb                         bc_call_sendb           rfvar count     bytes...
' h: call init
'
' i: @obj.sub                           bc_mptr_obj_sub         rfvar obj       rfvar sub
' j: @obj[].sub         push obji       bc_mptr_obji_sub        rfvar obj       rfvar sub
' k: @sub                               bc_mptr_sub                             rfvar sub
'
'
{
callobj         rfvar   w               'a b         g   i j    get obj into w
callsub         rfvar   v               'a b c       |   i j k  get sub into v
                getptr  pb              'a b c       g   i j k  get updated ptr
                jmp     #callh          'a b |       |   i j k  continue in hub
                jmp     #callsubh       '    c       |          continue in hub ('call sub' is optimized)
callptr         jmp     #callptrh       '      d     |          continue in hub
callrecv        jmp     #callrecvh      '        e   |          continue in hub
callsend        jmp     #callsendh      '          f |          continue in hub
                jmp     #callsendbh     '            g          continue in hub
}

callsendbh      call    #drophot        '            g          drop anchor
                mov     y,w             '            g          get count
                mov     z,pb            '            g          get data address
                setq    #3-1            '            g          push top of stack, count, data address
                wrlong  x,ptra++        '            g
                add     pb,w            '            g          set return address
                setbyte pb,#2,#3        '            g          set two parameters
                mov     x,#@pri_sendb   '            g          point to spin method
                jmp     #callhot        '            g          call spin method


callrecvh       cmp     mrecv,#0   wz   '        e              if mrecv <> 0 then valid
        if_nz   or      pbase,#%01      '        e              if valid, drop anchor with push flag set
        if_nz   call    #drophot        '        e
                pusha   x               '        e              push top of stack
                mov     x,mrecv         '        e              set top of stack to mrecv method ptr or 0 if invalid
        if_nz   skip    #%1111111_1     '        e              if valid, skip to method ptr call
resumeh         jmp     #resume         '        e              invalid, resume instead of calling method


callsendh       mov     y,x             '        | f            get parameter into y and pop stack
                popa    x               '        | f
                tjz     msend,#resumeh  '        | f            if msend = 0, resume instead of calling method
                call    #drophot        '        | f            drop anchor
                setq    #2-1            '        | f            push top of stack and parameter
                wrlong  x,ptra++        '        | f
                mov     x,msend         '        | f            set top of stack to msend method pointer


callptrh        mov     vbase,x         '      d e f            set vbase to ptr
                rdlong  pbase,vbase     '      d e f            read pbase from vbase
callinit        mov     v,vbase         '      d e f   h        get sub index from vbase[31:20]
                shr     v,#20           '      d e f   h
                zerox   vbase,#19       '      d e f   h        clear vbase msb's so they don't show up in @var
                jmp     #calloffh       '      d e f   h


callh           nop                     'a b             i j k  nop (instruction after branch cannot be skipped)

                add     w,x             '| b             | j |  add obj index

                shl     w,#3            'a b             i j |  get obj offsets from w
                add     w,pbase         'a b             i j |
                setq    #2-1            'a b             i j |
                rdlong  y,w             'a b             i j |  y = pbase offset, z = vbase offset

                jmp     #makeptr        '| |             i j k  if method ptr, continue in hub

                add     pbase,y         'a b                    add obj offsets into pbase/vbase
                add     vbase,z         'a b

callsubh        pusha   x               'a | c                  if no call index, push x to save parameter

calloffh        shl     v,#2            'a b c d e f   h        get sub offset
                add     v,pbase         'a b c d e f   h
                rdlong  v,v             'a b c d e f   h        get bytecode params/results/offset

                mov     x,v             'a b c d e f   h        convert offset to branch address
                add     x,pbase         'a b c d e f   h

                and     v,##$7FF00000   'a b c d e f   h  x2    save params/results above return_address
                or      pb,v            'a b c d e f   h

callhot         mov     dbase,dcall     'a b c d e f g h        set dbase to dcall
                mov     ptra,dbase      'a b c d e f g h        point to stack base
                rdlong  dcall,ptra[-1]  'a b c d e f g h        read prior dcall from stack
                wrlong  pb,ptra[-1]     'a b c d e f g h        write params/results/return_address into stack

                getbyte w,pb,#3         'a b c d e f g h        point past parameters
                shl     w,#2            'a b c d e f g h
                add     ptra,w          'a b c d e f g h

                getnib  w,pb,#5         'a b c d e f g h        clear results
                sub     w,#1    wc      'a b c d e f g h
        if_nc   setq    w               'a b c d e f g h
        if_nc   wrlong  #0,ptra++       'a b c d e f g h        points past results

                jmp     #callgo         'a b c d e f g h        continue in cog

{
callgo          rdfast  #0,x            'a b c d e f g h        return from hub, start new bytecode read
                rfvar   x               'a b c d e f g h        get number of local longs
        _ret_   djnf    x,#.clear       'a b c d e f g h        if zero, continue
.clear          setq    x               'a b c d e f g h        else, clear locals and point stack past them
        _ret_   wrlong  #0,ptra++       'a b c d e f g h
}

makeptr         shl     v,#20           '                i j k  shift up method index (instruction after branch cannot be skipped)

                pusha   x               '                i | k  if no index, push x

                mov     y,#0            '                | | k  get pbase/vbase for method
                mov     z,#0            '                | | k

                add     y,pbase         '                i j k  add pbase/vbase for obj
                add     z,vbase         '                i j k

                wrlong  y,z             '                i j k  write pbase to vbase (first vbase long is reserved for pbase ptr)

                zerox   z,#19           '                i j k  insert method index above vbase to make method pointer
                or      z,v             '                i j k

                mov     x,z             '                i j k  set top of stack to method pointer

        _ret_   rdfast  #0,pb           '                i j k  restart bytecode stream
'
'
' a: CASE_FAST init
'
' entry:
'
'   x           index
'   ptra[-1]    address
'
' exit:
'
'   x           address
'
'
' b: CASE_FAST done
'
' entry:
'
'   x           address
'
{
casefi          rflong  v               'a      get index base
                rfword  w               'a      get index limiter
                jmp     #casefih        'a      continue in hub

casefd          jmp     #casefdh        '  b    continue in hub
}

casefih         sub     x,v             'a      zero index
                fle     x,w             'a      limit index
                shl     x,#1            'a      make into word index
                add     pb,#4+2         'a      get rdfast pointer
                add     x,pb            'a      add rdfast pointer into word index
                rdword  a,x             'a      read offset word
                add     a,pb            'a      add rdfast pointer into offset word
casefdh         mov     a,x             '| b    get 'done' address
                popa    x               'a b    pop stack
                add     a,pbase         '| b    add pbase
        _ret_   rdfast  #0,a            'a b    branch to case code
'
'
' Make field
'
'    ^@reg                         -->   00_11111_00000_00000000000rrrrrrrrr
'    ^@reg.[bbbbb addbits sssss]   -->   00_sssss_bbbbb_00000000000rrrrrrrrr
'   ^@byte                         -->   01_00111_00000_aaaaaaaaaaaaaaaaaaaa
'   ^@byte.[bbbbb addbits sssss]   -->   01_sssss_bbbbb_aaaaaaaaaaaaaaaaaaaa
'   ^@word                         -->   10_01111_00000_aaaaaaaaaaaaaaaaaaaa
'   ^@word.[bbbbb addbits sssss]   -->   10_sssss_bbbbb_aaaaaaaaaaaaaaaaaaaa
'   ^@long                         -->   11_11111_00000_aaaaaaaaaaaaaaaaaaaa
'   ^@long.[bbbbb addbits sssss]   -->   11_sssss_bbbbb_aaaaaaaaaaaaaaaaaaaa
'
mfieldh         cmp     rd,rd_field     wz      'bitfield?
        if_z    mov     rd,rdf                  'if bitfield, retrieve rd
        if_nz   mov     fb,#0                   'if not bitfield, clear fb

                mov     x,sz                    'get sz into x

                cmp     rd,rd_word      wcz     'get type into x
                bitnc   x,#6                    'rd_byte --> 01
                bitnz   x,#5                    'rd_word --> 10
                cmp     rd,rd_byte      wc      'rd_long --> 11  (rd_reg < rd_byte)
        if_c    zerox   x,#4                    'rd_reg  --> 00

                shl     x,#5                    'get fb into x
                zerox   fb,#4
                or      x,fb

                shl     x,#20                   'get reg or ad into x
        if_c    sets    x,rd
        if_nc   zerox   ad,#19
        if_nc   or      x,ad

        _ret_   rdfast  #0,pb                   'restart bytecode stream
'
'
' Setup field with index
'
'   I = i * (sssss + 1)
'
'
'   [00_sssss_bbbbb_00000000000rrrrrrrrr][i]   -->   [00_sssss_BBBBB_00000000000RRRRRRRRR]
'
'               rrrrrrrrr00000
'       +                bbbbb
'       +       IIIIIIIIIIIIII
'       =       RRRRRRRRRBBBBB
'
'
'   [01_sssss_bbbbb_aaaaaaaaaaaaaaaaaaaa][i]   -->   [01_sssss_00BBB_AAAAAAAAAAAAAAAAAAAA]
'   [10_sssss_bbbbb_aaaaaaaaaaaaaaaaaaaa][i]   -->   [10_sssss_00BBB_AAAAAAAAAAAAAAAAAAAA]
'   [11_sssss_bbbbb_aaaaaaaaaaaaaaaaaaaa][i]   -->   [11_sssss_00BBB_AAAAAAAAAAAAAAAAAAAA]
'
'               aaaaaaaaaaaaaaaaaaaa000
'       +                         bbbbb
'       +       IIIIIIIIIIIIIIIIIIIIIII
'       =       AAAAAAAAAAAAAAAAAAAABBB
'
fieldih         mov     y,x                     'get index
                popa    x                       'pop field, tt_sssss_bbbbb_aaaaaaaaaaaaaaaaaaaa

                rol     x,#2+5                  'bbbbb_aaaaaaaaaaaaaaaaaaaa_tt_sssss
                test    x,#%11_00000    wz      'z=1 if reg, else byte/word/long

                mov     z,x                     'scale index by sssss+1
                and     z,#%11111
                add     z,#1
                getword w,y,#1
                mul     w,z
                shl     w,#16
                mul     y,z
                add     y,w

                mov     z,x                     'get address
                shr     z,#2+5
        if_z    shl     z,#5                    '------------------rrrrrrrrr00000 for reg
        if_nz   shl     z,#3                    '---------aaaaaaaaaaaaaaaaaaaa000 for byte/word/long

                mov     w,x                     'add bbbbb
                shr     w,#32-5
                add     z,w

                add     z,y                     'add scaled index

                shl     x,#32-2-5               'tt_sssss_00000_00000000000000000000

                mov     w,z                     'install updated bbbbb
        if_z    and     w,#%11111               'keep 5 lsb's for reg
        if_nz   and     w,#%00111               'keep 3 lsb's for byte/word/long
                shl     w,#20
                or      x,w

        if_z    shr     z,#5                    'install updated address
        if_z    zerox   z,#8
        if_nz   shr     z,#3
        if_nz   zerox   z,#19
                or      x,z                     '(followed by fieldh)
'
'
' Setup field
'
'   [00_sssss_bbbbb_-----------rrrrrrrrr]   -->    reg[-----------rrrrrrrrr].[bbbbb addbits sssss]
'   [01_sssss_bbbbb_aaaaaaaaaaaaaaaaaaaa]   -->   byte[aaaaaaaaaaaaaaaaaaaa].[bbbbb addbits sssss]
'   [10_sssss_bbbbb_aaaaaaaaaaaaaaaaaaaa]   -->   word[aaaaaaaaaaaaaaaaaaaa].[bbbbb addbits sssss]
'   [11_sssss_bbbbb_aaaaaaaaaaaaaaaaaaaa]   -->   long[aaaaaaaaaaaaaaaaaaaa].[bbbbb addbits sssss]
'
fieldh          testb   x,#31           wc      'get field type
                testb   x,#30           wz

        if_00   mov     rd,rd_reg               'reg?
        if_00   mov     wr,wr_reg
        if_00   sets    rd,x
        if_00   setd    wr,x

        if_01   mov     rd,rd_byte              'byte?
        if_01   mov     wr,wr_byte

        if_10   mov     rd,rd_word              'word?
        if_10   mov     wr,wr_word

        if_11   mov     rd,rd_long              'long?
        if_11   mov     wr,wr_long

                mov     ad,x                    'set address in case byte/word/long

                shr     x,#20                   'position fs and fb in x

                push    ##bit_p                 'ready to setup bitfield
        _ret_   rdfast  #0,pb                   'restart bytecode stream and setup bitfield
'
'
'***********************************************
'*  Interpreter - miscellaneous hub bytecodes  *
'***********************************************
'
'
' HUBSET(val)
'
hubset_         hubset  x                       'do hubset
        _ret_   popa    x                       'get top of stack
'
'
' CLKSET(clkmode,clkfreq)
'
clkset_         mov     z,x                     'get clkfreq into z

                setq    #2-1                    'get clkmode into y
                rdlong  x,--ptra                'get stack top into x

clkset_init     rep     #99,#1                  'use REP to stall interrupts until _ret_

                rdlong  w,#@clkmode_hub         'get current clkmode to avoid (PPPP = %1111) clock glitch
                andn    w,#%11                  'switch to 20MHz while maintaining old pll/xtal settings
                hubset  w

                test    y,#%10          wz      'if new pll/xtal settings then switch to 20MHz for 10ms
        if_nz   mov     w,y                     '..while new pll/xtal settings take effect
        if_nz   andn    w,#%11
        if_nz   hubset  w
        if_nz   wrlong  ##20_000_000,#@clkfreq_hub
        if_nz   waitx   ##20_000_000/100

                hubset  y                       'now switch to new settings

_debugnop1_     dirh    #63-63                  'write clkfreq to rx pin long repository
_debugnop2_     wxpin   z,#63-63
_debugnop3_     dirl    #63-63                  '(these 3 are NOP'd by compiler if not DEBUG, else fixed with debug_pin_rx)

                setq    #2-1                    'update clkmode and clkfreq
        _ret_   wrlong  y,#@clkmode_hub
'
'
' Read CLKFREQ
'
read_clkfreq    pusha   x

        _ret_   rdlong  x,#@clkfreq_hub
'
'
' COGSPIN(cog,method(parameters),stackadr)
'
' compile sequence:
'
'       cog                                     (COGSPIN)
'       0..127 parameters
'       method pointer
'       stackadr
'       bc_hub
'       bc_cogspin
'       byte: parameter count
'
'       bc_coginit/bc_coginit_push              (COGINIT)
'
' on entry:
'
'       x        = stackadr
'       ptra[-1] = method pointer
'       ptra[-2] = last parameter
'       ptra[-?] = first parameter
'       ptra[--] = cog
'       ptra[--] = prior top of stack
'
' on exit:
'
'       x        = stackadr                     ready for COGINIT(cog,pgm,ptr)
'       ptra[-1] = @launch_spin
'       ptra[-2] = cog | %10_0000
'       ptra[-3] = prior top of stack
'
cogspin_        mov     v,x                     'save stackadr

                popa    y                       'pop method pointer (vbase | method<<20) into y
                rdlong  x,y                     'get pbase into x
                setq    #2-1                    'write pbase and vbase at stackadr
                wrlong  x,v

                rdbyte  x,pb                    'read parameter count
                add     pb,#1           wz      'advance pointer, Z=0 for move_fwd_loop

                mov     y,x                     'ptrb points to first parameter
                shl     y,#2
                subr    y,ptra                  '(move_fwd_loop sets ptra to y and pops x)
                mov     ptrb,y

                mov     ptra,v                  'ptra points to parameter destination
                add     ptra,#6*4

                call    #move_fwd_loop          'copy any parameters, x=cog and ptra=@cog after

                or      x,#%10_0000             'set cog to hub-exec
                mov     y,##launch_spin         'set pgm to @launch_spin
                setq    #2-1                    'push cog/pgm
                wrlong  x,ptra++
        _ret_   mov     x,v                     'get stackadr on top of stack, ready for COGINIT(cog,pgm,ptr)
'
'
' Launch Spin - invoked by COGINIT
'
' on entry:
'
'       ptra[0]  = pbase
'       ptra[1]  = vbase | method<<20
'       ptra[6+] = any parameters
'
' on exit:
'
'       ptra[-6] = pbase | trap flag
'       ptra[-5] = vbase
'       ptra[-4] = dbase        @params...
'       ptra[-3] = mrecv
'       ptra[-2] = msend
'       ptra[-1] = return (w)   @COGSTOP(COGID)
'       ptra[ 0] = params...
'
launch_spin     loc     ptrb,#\$80000           'point to zeroes in empty hub space

                setq    #ptra-1                 'clear reg 0..ptra-1 (cancels mrecv/msend)
                rdlong  0,ptrb

                setq    #reg_end-reg_code-1     'load cog_code
                rdlong  reg_code,#@reg_code

                setq2   #(lut_code-1) & $1FF    'clear lut 0..lut_code-1
                rdlong  0,ptrb

                setq2   #lut_end-lut_code-1     'load lut_code
                rdlong  lut_code & $1FF,rdf

                setq    #2-1                    'get pbase/vbase
                rdlong  pbase,ptra

                or      pbase,#%10              'set pbase 'trap' flag

                mov     dbase,ptra              'set dbase to @params
                add     dbase,#6*4

                mov     w,dbase                 'set dcall value to be loaded

                setq    #6-1                    'write pbase/vbase/dbase/mrecv/msend/w into stack
                wrlong  pbase,ptra

                andn    pbase,#%11              'restore pbase address

                mov     dcall,dbase             'set dcall

                mov     pb,#@stopcog            'set return to COGSTOP(COGID) bytecodes

                push    #wrf_rd                 'return to wrf_rd to start xbyte after callinit

                jmp     #callinit               'begin bytecode execution of method in vbase[31:20]
'
'
' COGCHK(cog)
'
cogchk_         cogid   x               wc
        _ret_   muxc    x,_FFFFFFFF

'
'
' a: In-line PASM
' b: REGEXEC(hubadr)
' c: REGLOAD(hubadr)
' d: CALL(anyadr)
'
inline          setq    #16-1                   'a              load local variables from hub into buff
                rdlong  buff,dbase              'a
                bith    pb,#31                  'a              set flag to restore local variable to hub

                mov     ptrb,pb                 'a              get bytecode ptr into ptrb
                skip    ##%11100100000111       'a      x2      begin inline_pasm skip pattern

regexec_        skip    ##%1111000000           '| b    x2      begin REGEXEC skip pattern
regload_        mov     ptrb,x                  '| b c          get hubadr into ptrb

                rdword  w,ptrb++                'a b c          read start register
                rdword  y,ptrb++                'a b c          read length of pasm code, minus 1

                setq    y                       'a b c          read in code
                altd    w                       'a b c
                rdlong  0,ptrb++                'a b c          altd causes ptrb++ to inc by 4, not by (y+1)*4

        _ret_   popa    x                       '| | c          REGLOAD done, pop stack

                shl     y,#2                    'a |            update bytecode ptr for inline_pasm
                add     y,ptrb                  'a |

call_           mov     w,x                     '| |   d        get CALL address
                popa    x                       '| b   d        pop stack

                mov     y,pb                    '| b   d        save bytecode ptr
                mov     z,ptra                  'a b   d        save ptra

                call    w                       'a b   d        call pasm code (can use pa/pb/ptra/ptrb/stack, C/Z=0)

                mov     pb,y            wc      'a b   d        restore bytecode ptr

        if_c    setq    #16-1                   'a b   d        if inline_pasm, restore local variables to hub
        if_c    wrlong  buff,dbase              'a b   d

        _ret_   mov     ptra,z                  'a b   d        restore ptra
'
'
' GETREGS(hubadr,cogadr,longs)
' SETREGS(hubadr,cogadr,longs)
'
getregs_        setq    #3-1                    'x = longs
                rdlong  a,--ptra                'a = stack top, b = hubadr, c = cogadr

                sub     x,#1            wc      'if longs = 0, nothing to do

  if_nc         cmp     pa,#bc_getregs  wz      'GETREGS or SETREGS?

  if_nc_and_z   setq    x                       'GETREGS
  if_nc_and_z   altd    c
  if_nc_and_z   wrlong  0,b

  if_nc_and_nz  setq    x                       'SETREGS
  if_nc_and_nz  altd    c
  if_nc_and_nz  rdlong  0,b

  _ret_         mov     x,a                     'set stack top
'
'
' BYTEMOVE(dst,src,cnt)         +0
' BYTEFILL(dst,val,cnt)         +2
' WORDMOVE(dst,src,cnt)         +4
' WORDFILL(dst,val,cnt)         +6
' LONGMOVE(dst,src,cnt)         +8
' LONGFILL(dst,val,cnt)         +A
'
longmove_       shl     x,#1                    'cnt<<2 for long
wordmove_       shl     x,#1                    'cnt<<1 for word
bytemove_
                setq    #2-1                    'pop dst into buff+14
                rdlong  buff+14,--ptra          'pop src/val into buff+15

                mov     y,ptra                  'save ptra

                mov     ptra,buff+14            'set ptra to dst
                mov     ptrb,buff+15            'set ptrb to src/val

                testbn  pa,#1           wz      'move (Z=0) or fill (Z=1)?

  if_nz         cmp     ptrb,ptra       wc      'forward or reverse move?
  if_nz_and_nc  jmp     #move_fwd
  if_nz_and_c   jmp     #move_rev


                cmp     pa,#bc_longfill wc      'word fill?
  if_c          movbyts buff+15,#%%1010
                cmp     pa,#bc_wordfill wc      'byte fill?
  if_c          movbyts buff+15,#%%0000

                loc     pa,#fill_buff           'write fill pattern to stack
                call    #load_buff
                setq    #16-1                   'read fill pattern from stack into buff
                rdlong  buff,y


move_fwd        shr     x,#1            wc      'forward move/fill
  if_c_and_nz   rdbyte  buff,ptrb++
  if_c          wrbyte  buff,ptra++

                shr     x,#1            wc
  if_c_and_nz   rdword  buff,ptrb++
  if_c          wrword  buff,ptra++

move_fwd_loop   mov     w,#16
                fle     w,x
                sub     x,w
                djf     w,#move_done
  if_nz         setq    w
  if_nz         rdlong  buff,ptrb++
                setq    w
                wrlong  buff,ptra++
                jmp     #move_fwd_loop


move_rev        add     ptrb,x                  'reverse move
                add     ptra,x

                shr     x,#1            wc
  if_c          rdbyte  buff,--ptrb
  if_c          wrbyte  buff,--ptra

                shr     x,#1            wc
  if_c          rdword  buff,--ptrb
  if_c          wrword  buff,--ptra

move_rev_loop   mov     w,#16
                fle     w,x
                sub     x,w
                djf     w,#move_done
                setq    w
                rdlong  buff,--ptrb
                setq    w
                wrlong  buff,--ptra
                jmp     #move_rev_loop


move_done       mov     ptra,y                  'restore ptra
        _ret_   popa    x                       'get top of stack


fill_buff       not     buff+5,buff+15          'write fill pattern to stack
                shr     buff+5,#9
                not     buff+5
                setd    buff+6,buff+15
                setq    #16-1
                augd    #0                      'buff+5
        _ret_   wrlong  #0,y                    'buff+6
'
'
' STRSIZE(adr) : size
' STRCOMP(adra,adrb) : match
' STRCOPY(dst,src,max)
'
strsize_        loc     pa,#strsize_buff
                skip    #%1
strcomp_        loc     pa,#strcomp_buff
                skip    #%1
strcopy_        loc     pa,#strcopy_buff

load_buff       setq    #9-1                    'largest buff program is 9 longs
                rdlong  buff,pa
                jmp     #buff


strsize_buff    rdfast  #0,x                    'measure string
                mov     x,#0
.loop           rfbyte  y               wz
        if_nz   ijnz    x,#.loop
                ret

strcomp_buff    popa    ptrb                    'compare strings
                rdfast  #0,x
.loop           rdbyte  x,ptrb++
                rfbyte  y
                cmp     x,y             wz
        if_z    tjnz    x,#.loop
        _ret_   muxz    x,_FFFFFFFF

strcopy_buff    mov     w,x                     'copy string, get max into w
                setq    #3-1                    'pop top of stack into x, dst into y, src into z
                rdlong  x,--ptra
                mov     ptrb,y
                rdfast  #0,z
.loop           rfbyte  y               wz
                wrbyte  y,ptrb++
        if_nz   djnf    w,#.loop
        _ret_   wrbyte  #0,--ptrb
'
'
' GETCRC(ptr,poly,cnt) : crc
'
getcrc_         setq    #2-1                    'pop ptr into buff+14
                rdlong  buff+14,--ptra          'pop poly into buff+15

                mov     y,x                     'get cnt into y

                encod   x,buff+15               'get starting value into x
                bmask   x

                loc     pa,#getcrc_buff         'if cnt <> 0 then run crc, else x=result
        _ret_   tjnz    y,#load_buff


getcrc_buff     rdfast  #0,buff+14              'compute crc of bytes
.loop           rfbyte  w
                shl     w,#24
                setq    w
                crcnib  x,buff+15
                crcnib  x,buff+15
        _ret_   djnz    y,#.loop
'
'
' WAITUS(us)
' WAITMS(ms)
'
waitus_         getct   w                       'get ct now to minimize error

                rdlong  y,#@clkfreq_hub         'get clock frequency

                rep     @.stall,#1              'use REP to stall interrupts to protect cordic operation
                qmul    y,x                     'multiply clock frequency by us/ms
                getqx   x
                getqy   y
.stall
                cmp     pa,#bc_waitus   wz      'us or ms time unit?
                mov     z,##1000
        if_z    mul     z,z

                rep     @.stall2,#1             'use REP to stall interrupts to protect cordic operation
                setq    y                       'divide by time unit
                qdiv    x,z
                getqx   x
.stall2
                add     x,w                     'add ct

                jmp     #pwct                   'do WAITCT
'
'
' GETMS() : millseconds
' GETSEC() : seconds
' MULDIV64(m1,m2,d) : quotient
'
muldiv64_       setq    #2-1                    'pop m1 and m2, open top of stack
                rdlong  y,--ptra                'x=d, y=m1, z=m2

                rep     @.stall,#1              'use REP to stall interrupts to protect cordic operation
                qmul    y,z                     'multiply m1 * m2
                getqx   y                       'product in {z,y}
                getqy   z
.stall
                skip    #%11_11_1               'skip to rep


getms_          pusha   x                       'push stack to open top of stack

                rdlong  w,#@clkfreq_hub         'get clkfreq into w and x
                mov     x,w

                getct   z               wc      'get 64-bit clock count into {z,y}
                getct   y

                rep     @.stall,#1              'use REP to stall interrupts to protect cordic operation
                setq    z                       'divide {z,y} by x
                qdiv    y,x
                getqy   y                       'remainder in y (fractional seconds)
                getqx   x                       'quotient in x (seconds)
.stall
                cmp     pa,#bc_getms    wz      'if not GETMS then done
        if_nz   ret

                rep     @.stall2,#1             'use REP to stall interrupts to protect cordic operation
                qmul    x,##1000                'multiply seconds by 1000 to get whole-second milliseconds
                getqx   x
.stall2
                nop                             'accommodate any pending interrupt

                rep     @.stall3,#1             'use REP stall interrupts to protect cordic operation
                qfrac   y,w                     'compute (fractional seconds << 32 / clkfreq) to get scale
                getqx   y                       'get scale ($FFFF_FFFF = ~1.0)
.stall3
                nop                             'accommodate any pending interrupt

                rep     @.stall4,#1             'use REP to stall interrupts to protect cordic operation
                qmul    y,##1000                'multiply scale by 1000 to get fractional-second milliseconds
                getqy   y                       'get fractional-second milliseconds (0..999)
.stall4
        _ret_   add     x,y                     'add fractional-second milliseconds into whole-second milliseconds
'
'
' QSIN(rho,theta,twopi) : y
' QCOS(rho,theta,twopi) : x
'
qsin_           setq    #2-1                    'pop rho and theta, open top of stack
                rdlong  y,--ptra                'x=twopi, y=rho, z=theta

                tjz     x,#.fullscale

                rep     @.stall,#1              'use REP to stall interrupts to protect cordic operation
                qfrac   #1,x                    'divide $1_0000_0000 by twopi
                getqx   x                       'get angle unit
.stall
                nop                             'accommodate any pending interrupt

                rep     @.stall2,#1             'use REP to stall interrupts to protect cordic operation
                qmul    z,x                     'multiply theta by angle unit to get 32-bit angle
                getqx   z
.stall2
.fullscale      cmp     pa,#bc_qsin     wz      'return sine or cosine?

                rep     @.stall3,#1             'use REP to stall interrupts to protect cordic operation
                qrotate y,z                     'rotate (rho,0) by theta
        if_z    getqy   x
        if_nz   getqx   x
.stall3
                ret
'
'
' ROTXY(x,y,t) : rotx, roty
' POLXY(r,t) : x, y
' XYPOL(x,y) : r, t
'
rotxy_          setq    #2-1                    'pop x and y for ROTXY
polxy_          rdlong  y,--ptra                'pop r/x for POLXY/XYPOL
                cmp     pa,#bc_polxy    wcz     'flags differentiate ROTXY/POLXY/XYPOL
                rep     #99,#1                  'use REP to stall interrupts to protect cordic operation until _ret_
        if_b    setq    z                       'if ROTXY, do SETQ
        if_be   qrotate y,x                     'if ROTXY/POLXY, do QROTATE
        if_a    qvector y,x                     'if XYPOL, do QVECTOR
                getqx   x                       'get results
                pusha   x
        _ret_   getqy   x
'
'
'************************************************
'*  Interpreter - floating-point hub bytecodes  *
'************************************************
'
'
' NAN(float)            float ma --> boolean x
'
nan_            call    #unpackf                'unpack float

        _ret_   neg     x,na                    'return NaN status
'
'
' -.float               float ma --> float ma
'
fneg_   _ret_   bitnot  ma,#31                  'negate float
'
'
' FABS(float)           float ma --> float ma
'
fabs_   _ret_   bitl    ma,#31                  'absolutize float
'
'
' FSQRT(float)          float ma --> float ma
'
fsqrt_          call    #unpackf                'unpack float

                tjz     ma,#fabs_               'if mantissa zero, got result, use _ret_ in FABS

                or      na,sa                   'if negative, result = NaN

                sar     xa,#1           wc      'halve root exponent
        if_nc   shr     ma,#1                   'if exponent was even, shift mantissa down
                sub     xa,#1                   'decrement to account for bit29 justification

                rep     @.stall,#1              'use REP to stall interrupts to protect cordic operation
                qsqrt   #0,ma                   'compute square root of mantissa
                getqx   ma
.stall
                jmp     #packf                  'pack result
'
'
' float -. float
' float +. float
'
fsub_           bitnot  ma,#31                  'negate right-hand float

fadd_           call    #unpackf2               'unpack two floats

                or      na,nb                   'if either NaN, result NaN

                test    sa              wz      'negate ma?
                negnz   ma

                test    sb              wz      'negate mb?
                negnz   mb

                mov     y,xa                    'determine greater exponent
                subs    y,xb            wcz     'xa > xb ?

                abs     y                       'absolutize and clamp exponent difference
                fle     y,#31

        if_a    sar     mb,y                    'shift lower-exponent mantissa down
        if_be   sar     ma,y
        if_be   mov     xa,xb

                add     ma,mb                   'add mantissas
                abs     ma              wc      'absolutize result
                wrc     sa                      'set sign

                jmp     #packf                  'pack result
'
'
' float *. float
'
fmul_           call    #unpackf2               'unpack two floats

                or      na,nb                   'if either NaN, result NaN

                xor     sa,sb                   'xor signs
                add     xa,xb                   'add exponents

                rep     @.stall,#1              'use REP to stall interrupts to protect cordic operation
                qmul    ma,mb                   'compute upper product of ma * mb
                getqy   ma
.stall
                shl     ma,#3                   'justify product

                jmp     #packf                  'pack result
'
'
' float /. float
'
fdiv_           call    #unpackf2               'unpack two floats

                or      na,nb                   'if either Nan, result NaN

                test    mb              wz      'if denominator zero, result NaN
        if_z    mov     na,#1

                xor     sa,sb                   'xor signs
                sub     xa,xb                   'subtract exponents

                shr     ma,#1                   'make ma < mb

                rep     @.stall,#1              'use REP to stall interrupts to protect cordic operation
                qfrac   ma,mb                   'compute quotient of (ma << 32) / mb
                getqx   ma
.stall
                shr     ma,#2                   'justify quotient

                jmp     #packf                  'pack result
'
'
' 001: float <.  float           --> boolean x
' 010: float >.  float           --> boolean x
' 011: float <>. float           --> boolean x
' 100: float ==. float           --> boolean x
' 101: float <=. float           --> boolean x
' 110: float >=. float           --> boolean x
'
frel_           popa    w                       'pop left-side float

                bitl    w,#31           wcz     'make left-side comparable
                cmp     w,##$7F800001   wc      'NaN?
        if_nc   skip    #%1111                  'if NaN, return false
        if_z    neg     w                       '+/- %0_xxxxxxxx_mmmmmmmmmmmmmmmmmmmmmmm

                bitl    x,#31           wcz     'make right-side comparable
                cmp     x,##$7F800001   wc      'NaN?
        if_nc   skip    #%111111                'if NaN, return false
        if_z    neg     x                       '+/- %0_xxxxxxxx_mmmmmmmmmmmmmmmmmmmmmmm

                cmps    w,x             wcz     'do comparison
        if_z    mov     y,#%1000                'equal?
        if_nz   mov     y,#%0100                'above?
        if_c    mov     y,#%0010                'below?
                test    y,pa            wc      'test mask

        _ret_   muxc    x,_FFFFFFFF             'return boolean
'
'
' TRUNC(float)          float ma --> integer ma
' ROUND(float)          float ma --> integer ma
'
round_          call    #unpackf                'unpack float

                add     xa,#1                   'if exponent < -1 or exponent > 30 then return zero
                cmp     xa,#32          wc
        if_nc   mov     ma,#0

                shl     ma,#31-29
                subr    xa,#31
                shr     ma,xa
                testb   pa,#1           wc      'TRUNC or ROUND?
        if_c    add     ma,#1
                shr     ma,#1
                testb   sa,#0           wc
        _ret_   negc    ma
'
'
' FLOAT(integer)        integer ma --> float ma
'
float_          mov     na,#0                   'clear NaN
                abs     ma              wc      'get sign, make integer absolute
                wrc     sa                      'set sign
                encod   xa,ma                   'get exponent
                ror     ma,xa                   'bit29-justify mantissa
                ror     ma,#1
                shr     ma,#2

                jmp     #packf                  'pack result
'
'
' Unpack two floats
'
unpackf2        call    #unpackf                'unpack ma

                mov     nb,na                   'copy na/sa/xa/ma to nb/sb/xb/mb
                mov     sb,sa
                mov     xb,xa
                mov     mb,ma

                popa    ma                      'pop new ma (followed by fp_unpack)
'
'
' Unpack float          float ma --> na,sa,xa,ma
'
unpackf         bitl    ma,#31          wcz     'read and clear sign
                wrc     sa

                cmpr    ma,##$7F800000  wc      'check for NaN
                wrc     na

                mov     xa,ma                   'get exponent
                shr     xa,#32-1-8      wz

                zerox   ma,#22                  'get mantissa

        if_nz   bith    ma,#23                  'if exponent <> 0 then insert leading one
        if_nz   shl     ma,#29-23               '...bit29-justify mantissa

        if_z    encod   xa,ma                   'if exponent = 0 then get magnitude of mantissa
        if_z    ror     ma,xa                   '...bit29-justify mantissa
        if_z    ror     ma,#32-29
        if_z    sub     xa,#22                  '...adjust exponent to -22..0

        _ret_   sub     xa,#127                 'unbias exponent
'
'
' Pack float            na,sa,xa,ma --> float ma
'
packf           testbn  na,#0           wc      'if NaN, result $FFFFFFFF
        if_nc   not     ma,#0

        if_c    encod   y,ma            wc      'determine magnitude of mantissa
        if_nc   ret                             'if NaN or mantissa=0 (result 0), done

                ror     ma,y                    'msb-justify mantissa without leading 1
                bitl    ma,#0                   'clear leading 1 now in lsb

                mov     mb,ma                   'check if mantissa is even with 0.500 fraction
                zerox   mb,#9           wc      'clear msb's, c=0 for addx in case no rounding
                cmp     mb,#%0100000000 wz      'even with 0.500 fraction?
        if_nz   add     ma,#%0100000000 wc      'if not, round up mantissa by 0.500

                addx    xa,y                    'adjust exponent and account for rounding overflow
                add     xa,#127-29              'bias exponent

                fges    xa,##-23                'limit exponent to -23..255
                fles    xa,#255         wc      'if 255 and mantissa not 0, NaN
        if_c    not     ma,#0                   'if >255, force Nan by making mantissa not 0

                cmps    xa,#1           wc      'exponent < 1?

        if_c    rcr     ma,#1                   'if so, replace leading 1
        if_c    neg     xa                      'shift mantissa down by exponent
        if_c    shr     ma,xa                   'if exponent is -23, mantissa becomes 0

                shr     ma,#8                   'make room for exponent
        if_nc   setbyte ma,xa,#3                'if exponent < 1 then leave at 0, else install

                testb   sa,#0           wc      'install sign bit
        _ret_   rcr     ma,#1
'
'
'*********
'*  END  *
'*********
'
'
' Test bytecode program
'
                alignl                          'align to long for clean pbase
test_pbase      'file   "untitled.obj"
                alignl                          'align to long for clean vbase
test_vbase      'long   0[100]
                alignl                          'align to long for clean dbase
test_dbase      'long   0[100]
