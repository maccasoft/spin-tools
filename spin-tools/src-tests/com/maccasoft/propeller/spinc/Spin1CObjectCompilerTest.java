/*
 * Copyright (c) 2021-24 Marco Maccaferri and others.
 * All rights reserved.
 *
 * This program and the accompanying materials are made available under
 * the terms of the Eclipse Public License v1.0 which accompanies this
 * distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 */

package com.maccasoft.propeller.spinc;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.PrintStream;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import com.maccasoft.propeller.CompilerException;
import com.maccasoft.propeller.model.Node;
import com.maccasoft.propeller.spin1.Spin1Compiler;
import com.maccasoft.propeller.spin1.Spin1Object;

class Spin1CObjectCompilerTest {

    @Test
    void testEmptyFunction() throws Exception {
        String text = ""
            + "void main()\n"
            + "{\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 0)\n"
            + "00000 00000       0C 00          Object size\n"
            + "00002 00002       02             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       08 00 00 00    Function main @ $0008 (local size 0)\n"
            + "' void main() {\n"
            + "' }\n"
            + "00008 00008       32             RETURN\n"
            + "00009 00009       00 00 00       Padding\n"
            + "", compile(text));
    }

    @Test
    void testParameterVarAssignment() throws Exception {
        String text = ""
            + "void main(int a)\n"
            + "{\n"
            + "    a = 1;\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 0)\n"
            + "00000 00000       0C 00          Object size\n"
            + "00002 00002       02             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       08 00 00 00    Function main @ $0008 (local size 0)\n"
            + "' void main(int a) {\n"
            + "'     a = 1;\n"
            + "00008 00008       36             CONSTANT (1)\n"
            + "00009 00009       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "' }\n"
            + "0000A 0000A       32             RETURN\n"
            + "0000B 0000B       00             Padding\n"
            + "", compile(text));
    }

    @Test
    void testLocalVarAssignment() throws Exception {
        String text = ""
            + "void main()\n"
            + "{\n"
            + "    int a;\n"
            + "\n"
            + "    a = 1;\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 0)\n"
            + "00000 00000       0C 00          Object size\n"
            + "00002 00002       02             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       08 00 04 00    Function main @ $0008 (local size 4)\n"
            + "' void main() {\n"
            + "'     a = 1;\n"
            + "00008 00008       36             CONSTANT (1)\n"
            + "00009 00009       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "' }\n"
            + "0000A 0000A       32             RETURN\n"
            + "0000B 0000B       00             Padding\n"
            + "", compile(text));
    }

    @Test
    void testLocalVarDeclarationAndAssignment() throws Exception {
        String text = ""
            + "void main()\n"
            + "{\n"
            + "    int a = 1;\n"
            + "    int b = 2, c = 3, d = 4;\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 0)\n"
            + "00000 00000       14 00          Object size\n"
            + "00002 00002       02             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       08 00 10 00    Function main @ $0008 (local size 16)\n"
            + "' void main() {\n"
            + "'     int a = 1;\n"
            + "00008 00008       36             CONSTANT (1)\n"
            + "00009 00009       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "'     int b = 2, c = 3, d = 4;\n"
            + "0000A 0000A       38 02          CONSTANT (2)\n"
            + "0000C 0000C       69             VAR_WRITE LONG DBASE+$0008 (short)\n"
            + "0000D 0000D       38 03          CONSTANT (3)\n"
            + "0000F 0000F       6D             VAR_WRITE LONG DBASE+$000C (short)\n"
            + "00010 00010       38 04          CONSTANT (4)\n"
            + "00012 00012       71             VAR_WRITE LONG DBASE+$0010 (short)\n"
            + "' }\n"
            + "00013 00013       32             RETURN\n"
            + "", compile(text));
    }

    @Test
    void testGlobalVarAssignment() throws Exception {
        String text = ""
            + "long a = 1;\n"
            + "byte b = 2;\n"
            + "word c = 0, d = 0;\n"
            + "\n"
            + "void main()\n"
            + "{\n"
            + "    c = 3;\n"
            + "    d = 4;\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 12)\n"
            + "00000 00000       20 00          Object size\n"
            + "00002 00002       02             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       08 00 00 00    Function main @ $0008 (local size 0)\n"
            + "' void main() {\n"
            + "00008 00008       36             CONSTANT (1)\n"
            + "00009 00009       41             VAR_WRITE LONG VBASE+$0000 (short)\n"
            + "0000A 0000A       38 02          CONSTANT (2)\n"
            + "0000C 0000C       89 04          VAR_WRITE BYTE VBASE+$0004\n"
            + "0000E 0000E       35             CONSTANT (0)\n"
            + "0000F 0000F       A9 06          VAR_WRITE WORD VBASE+$0006\n"
            + "00011 00011       35             CONSTANT (0)\n"
            + "00012 00012       A9 08          VAR_WRITE WORD VBASE+$0008\n"
            + "'     c = 3;\n"
            + "00014 00014       38 03          CONSTANT (3)\n"
            + "00016 00016       A9 06          VAR_WRITE WORD VBASE+$0006\n"
            + "'     d = 4;\n"
            + "00018 00018       38 04          CONSTANT (4)\n"
            + "0001A 0001A       A9 08          VAR_WRITE WORD VBASE+$0008\n"
            + "' }\n"
            + "0001C 0001C       32             RETURN\n"
            + "0001D 0001D       00 00 00       Padding\n"
            + "", compile(text));
    }

    @Test
    void testExpressionAssignment() throws Exception {
        String text = ""
            + "int a, b;\n"
            + "\n"
            + "void main()\n"
            + "{\n"
            + "    a = 1 + b * 3;\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 8)\n"
            + "00000 00000       10 00          Object size\n"
            + "00002 00002       02             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       08 00 00 00    Function main @ $0008 (local size 0)\n"
            + "' void main() {\n"
            + "'     a = 1 + b * 3;\n"
            + "00008 00008       36             CONSTANT (1)\n"
            + "00009 00009       44             VAR_READ LONG VBASE+$0004 (short)\n"
            + "0000A 0000A       38 03          CONSTANT (3)\n"
            + "0000C 0000C       F4             MULTIPLY\n"
            + "0000D 0000D       EC             ADD\n"
            + "0000E 0000E       41             VAR_WRITE LONG VBASE+$0000 (short)\n"
            + "' }\n"
            + "0000F 0000F       32             RETURN\n"
            + "", compile(text));
    }

    @Test
    void testMethodCall() throws Exception {
        String text = ""
            + "int a;\n"
            + "\n"
            + "void main()\n"
            + "{\n"
            + "    setup();\n"
            + "}\n"
            + "\n"
            + "void setup() {\n"
            + "    a = 1;\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 4)\n"
            + "00000 00000       14 00          Object size\n"
            + "00002 00002       03             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       0C 00 00 00    Function main @ $000C (local size 0)\n"
            + "00008 00008       10 00 00 00    Function setup @ $0010 (local size 0)\n"
            + "' void main() {\n"
            + "'     setup();\n"
            + "0000C 0000C       01             ANCHOR\n"
            + "0000D 0000D       05 02          CALL_SUB (1)\n"
            + "' }\n"
            + "0000F 0000F       32             RETURN\n"
            + "' void setup() {\n"
            + "'     a = 1;\n"
            + "00010 00010       36             CONSTANT (1)\n"
            + "00011 00011       41             VAR_WRITE LONG VBASE+$0000 (short)\n"
            + "' }\n"
            + "00012 00012       32             RETURN\n"
            + "00013 00013       00             Padding\n"
            + "", compile(text));
    }

    @Test
    void testForLoop() throws Exception {
        String text = ""
            + "int a;\n"
            + "\n"
            + "void main()\n"
            + "{\n"
            + "    for(;;) {\n"
            + "    }\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 4)\n"
            + "00000 00000       0C 00          Object size\n"
            + "00002 00002       02             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       08 00 00 00    Function main @ $0008 (local size 0)\n"
            + "' void main() {\n"
            + "'     for(;;) {\n"
            + "00008 00008       04 7E          JMP $00008 (-2)\n"
            + "'     }\n"
            + "' }\n"
            + "0000A 0000A       32             RETURN\n"
            + "0000B 0000B       00             Padding\n"
            + "", compile(text));
    }

    @Test
    void testForLoopBreakAndContinue() throws Exception {
        String text = ""
            + "int a, b;\n"
            + "\n"
            + "void main()\n"
            + "{\n"
            + "    for(;;) {\n"
            + "        if (a == 10) {\n"
            + "            b++;\n"
            + "            continue;\n"
            + "        }\n"
            + "        if (a == 20) {\n"
            + "            b = 1;\n"
            + "            break;\n"
            + "        }\n"
            + "        b += 2;\n"
            + "    }\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 8)\n"
            + "00000 00000       24 00          Object size\n"
            + "00002 00002       02             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       08 00 00 00    Function main @ $0008 (local size 0)\n"
            + "' void main() {\n"
            + "'     for(;;) {\n"
            + "'         if (a == 10) {\n"
            + "00008 00008       40             VAR_READ LONG VBASE+$0000 (short)\n"
            + "00009 00009       38 0A          CONSTANT (10)\n"
            + "0000B 0000B       FC             TEST_EQUAL\n"
            + "0000C 0000C       0A 04          JZ $00012 (4)\n"
            + "'             b++;\n"
            + "0000E 0000E       46             VAR_MODIFY LONG VBASE+$0004 (short)\n"
            + "0000F 0000F       2E             POST_INC\n"
            + "'             continue;\n"
            + "00010 00010       04 76          JMP $00008 (-10)\n"
            + "'         }\n"
            + "'         if (a == 20) {\n"
            + "00012 00012       40             VAR_READ LONG VBASE+$0000 (short)\n"
            + "00013 00013       38 14          CONSTANT (20)\n"
            + "00015 00015       FC             TEST_EQUAL\n"
            + "00016 00016       0A 04          JZ $0001C (4)\n"
            + "'             b = 1;\n"
            + "00018 00018       36             CONSTANT (1)\n"
            + "00019 00019       45             VAR_WRITE LONG VBASE+$0004 (short)\n"
            + "'             break;\n"
            + "0001A 0001A       04 06          JMP $00022 (6)\n"
            + "'         }\n"
            + "'         b += 2;\n"
            + "0001C 0001C       38 02          CONSTANT (2)\n"
            + "0001E 0001E       46             VAR_MODIFY LONG VBASE+$0004 (short)\n"
            + "0001F 0001F       4C             ADD\n"
            + "00020 00020       04 66          JMP $00008 (-26)\n"
            + "'     }\n"
            + "' }\n"
            + "00022 00022       32             RETURN\n"
            + "00023 00023       00             Padding\n"
            + "", compile(text));
    }

    @Test
    void testForLoopTwoArguments() throws Exception {
        String text = ""
            + "int a;\n"
            + "\n"
            + "void main()\n"
            + "{\n"
            + "    for(a = 0; a < 100;) {\n"
            + "        a++;\n"
            + "    }\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 4)\n"
            + "00000 00000       18 00          Object size\n"
            + "00002 00002       02             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       08 00 00 00    Function main @ $0008 (local size 0)\n"
            + "' void main() {\n"
            + "'     for(a = 0; a < 100;) {\n"
            + "00008 00008       35             CONSTANT (0)\n"
            + "00009 00009       41             VAR_WRITE LONG VBASE+$0000 (short)\n"
            + "0000A 0000A       40             VAR_READ LONG VBASE+$0000 (short)\n"
            + "0000B 0000B       38 64          CONSTANT (100)\n"
            + "0000D 0000D       F9             TEST_BELOW\n"
            + "0000E 0000E       0A 04          JZ $00014 (4)\n"
            + "'         a++;\n"
            + "00010 00010       42             VAR_MODIFY LONG VBASE+$0000 (short)\n"
            + "00011 00011       2E             POST_INC\n"
            + "00012 00012       04 76          JMP $0000A (-10)\n"
            + "'     }\n"
            + "' }\n"
            + "00014 00014       32             RETURN\n"
            + "00015 00015       00 00 00       Padding\n"
            + "", compile(text));
    }

    @Test
    void testForLoopThreeArguments() throws Exception {
        String text = ""
            + "int a, b;\n"
            + "\n"
            + "void main()\n"
            + "{\n"
            + "    for(a = 0; a < 100; a++) {\n"
            + "        b++;\n"
            + "    }\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 8)\n"
            + "00000 00000       18 00          Object size\n"
            + "00002 00002       02             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       08 00 00 00    Function main @ $0008 (local size 0)\n"
            + "' void main() {\n"
            + "'     for(a = 0; a < 100; a++) {\n"
            + "00008 00008       35             CONSTANT (0)\n"
            + "00009 00009       41             VAR_WRITE LONG VBASE+$0000 (short)\n"
            + "0000A 0000A       40             VAR_READ LONG VBASE+$0000 (short)\n"
            + "0000B 0000B       38 64          CONSTANT (100)\n"
            + "0000D 0000D       F9             TEST_BELOW\n"
            + "0000E 0000E       0A 06          JZ $00016 (6)\n"
            + "'         b++;\n"
            + "00010 00010       46             VAR_MODIFY LONG VBASE+$0004 (short)\n"
            + "00011 00011       2E             POST_INC\n"
            + "00012 00012       42             VAR_MODIFY LONG VBASE+$0000 (short)\n"
            + "00013 00013       2E             POST_INC\n"
            + "00014 00014       04 74          JMP $0000A (-12)\n"
            + "'     }\n"
            + "' }\n"
            + "00016 00016       32             RETURN\n"
            + "00017 00017       00             Padding\n"
            + "", compile(text));
    }

    @Test
    void testForLoopMultipleInits() throws Exception {
        String text = ""
            + "int a, b;\n"
            + "\n"
            + "void main()\n"
            + "{\n"
            + "    for(a = 0, b = 1; a < 100; a++) {\n"
            + "        b++;\n"
            + "    }\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 8)\n"
            + "00000 00000       1C 00          Object size\n"
            + "00002 00002       02             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       08 00 00 00    Function main @ $0008 (local size 0)\n"
            + "' void main() {\n"
            + "'     for(a = 0, b = 1; a < 100; a++) {\n"
            + "00008 00008       35             CONSTANT (0)\n"
            + "00009 00009       41             VAR_WRITE LONG VBASE+$0000 (short)\n"
            + "0000A 0000A       36             CONSTANT (1)\n"
            + "0000B 0000B       45             VAR_WRITE LONG VBASE+$0004 (short)\n"
            + "0000C 0000C       40             VAR_READ LONG VBASE+$0000 (short)\n"
            + "0000D 0000D       38 64          CONSTANT (100)\n"
            + "0000F 0000F       F9             TEST_BELOW\n"
            + "00010 00010       0A 06          JZ $00018 (6)\n"
            + "'         b++;\n"
            + "00012 00012       46             VAR_MODIFY LONG VBASE+$0004 (short)\n"
            + "00013 00013       2E             POST_INC\n"
            + "00014 00014       42             VAR_MODIFY LONG VBASE+$0000 (short)\n"
            + "00015 00015       2E             POST_INC\n"
            + "00016 00016       04 74          JMP $0000C (-12)\n"
            + "'     }\n"
            + "' }\n"
            + "00018 00018       32             RETURN\n"
            + "00019 00019       00 00 00       Padding\n"
            + "", compile(text));
    }

    @Test
    void testWhileLoop() throws Exception {
        String text = ""
            + "int a;\n"
            + "\n"
            + "void main()\n"
            + "{\n"
            + "    while(a < 100) {\n"
            + "        a++;\n"
            + "    }\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 4)\n"
            + "00000 00000       14 00          Object size\n"
            + "00002 00002       02             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       08 00 00 00    Function main @ $0008 (local size 0)\n"
            + "' void main() {\n"
            + "'     while(a < 100) {\n"
            + "00008 00008       40             VAR_READ LONG VBASE+$0000 (short)\n"
            + "00009 00009       38 64          CONSTANT (100)\n"
            + "0000B 0000B       F9             TEST_BELOW\n"
            + "0000C 0000C       0A 04          JZ $00012 (4)\n"
            + "'         a++;\n"
            + "0000E 0000E       42             VAR_MODIFY LONG VBASE+$0000 (short)\n"
            + "0000F 0000F       2E             POST_INC\n"
            + "00010 00010       04 76          JMP $00008 (-10)\n"
            + "'     }\n"
            + "' }\n"
            + "00012 00012       32             RETURN\n"
            + "00013 00013       00             Padding\n"
            + "", compile(text));
    }

    @Test
    void testWhileLoopBreakAndContinue() throws Exception {
        String text = ""
            + "int a, b;\n"
            + "\n"
            + "void main()\n"
            + "{\n"
            + "    while(a < 100) {\n"
            + "        if (a == 10) {\n"
            + "            b++;\n"
            + "            continue;\n"
            + "        }\n"
            + "        if (a == 20) {\n"
            + "            b = 1;\n"
            + "            break;\n"
            + "        }\n"
            + "        a++;\n"
            + "    }\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 8)\n"
            + "00000 00000       28 00          Object size\n"
            + "00002 00002       02             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       08 00 00 00    Function main @ $0008 (local size 0)\n"
            + "' void main() {\n"
            + "'     while(a < 100) {\n"
            + "00008 00008       40             VAR_READ LONG VBASE+$0000 (short)\n"
            + "00009 00009       38 64          CONSTANT (100)\n"
            + "0000B 0000B       F9             TEST_BELOW\n"
            + "0000C 0000C       0A 18          JZ $00026 (24)\n"
            + "'         if (a == 10) {\n"
            + "0000E 0000E       40             VAR_READ LONG VBASE+$0000 (short)\n"
            + "0000F 0000F       38 0A          CONSTANT (10)\n"
            + "00011 00011       FC             TEST_EQUAL\n"
            + "00012 00012       0A 04          JZ $00018 (4)\n"
            + "'             b++;\n"
            + "00014 00014       46             VAR_MODIFY LONG VBASE+$0004 (short)\n"
            + "00015 00015       2E             POST_INC\n"
            + "'             continue;\n"
            + "00016 00016       04 70          JMP $00008 (-16)\n"
            + "'         }\n"
            + "'         if (a == 20) {\n"
            + "00018 00018       40             VAR_READ LONG VBASE+$0000 (short)\n"
            + "00019 00019       38 14          CONSTANT (20)\n"
            + "0001B 0001B       FC             TEST_EQUAL\n"
            + "0001C 0001C       0A 04          JZ $00022 (4)\n"
            + "'             b = 1;\n"
            + "0001E 0001E       36             CONSTANT (1)\n"
            + "0001F 0001F       45             VAR_WRITE LONG VBASE+$0004 (short)\n"
            + "'             break;\n"
            + "00020 00020       04 04          JMP $00026 (4)\n"
            + "'         }\n"
            + "'         a++;\n"
            + "00022 00022       42             VAR_MODIFY LONG VBASE+$0000 (short)\n"
            + "00023 00023       2E             POST_INC\n"
            + "00024 00024       04 62          JMP $00008 (-30)\n"
            + "'     }\n"
            + "' }\n"
            + "00026 00026       32             RETURN\n"
            + "00027 00027       00             Padding\n"
            + "", compile(text));
    }

    @Test
    void testDoWhileLoop() throws Exception {
        String text = ""
            + "int a;\n"
            + "\n"
            + "void main()\n"
            + "{\n"
            + "    do {\n"
            + "        a++;\n"
            + "    } while(a < 100);\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 4)\n"
            + "00000 00000       14 00          Object size\n"
            + "00002 00002       02             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       08 00 00 00    Function main @ $0008 (local size 0)\n"
            + "' void main() {\n"
            + "'     do {\n"
            + "'         a++;\n"
            + "00008 00008       42             VAR_MODIFY LONG VBASE+$0000 (short)\n"
            + "00009 00009       2E             POST_INC\n"
            + "'     } while(a < 100);\n"
            + "0000A 0000A       40             VAR_READ LONG VBASE+$0000 (short)\n"
            + "0000B 0000B       38 64          CONSTANT (100)\n"
            + "0000D 0000D       F9             TEST_BELOW\n"
            + "0000E 0000E       0B 78          JNZ $00008 (-8)\n"
            + "' }\n"
            + "00010 00010       32             RETURN\n"
            + "00011 00011       00 00 00       Padding\n"
            + "", compile(text));
    }

    @Test
    void testDoUntilLoop() throws Exception {
        String text = ""
            + "int a;\n"
            + "\n"
            + "void main()\n"
            + "{\n"
            + "    do {\n"
            + "        a++;\n"
            + "    } until(a > 100);\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 4)\n"
            + "00000 00000       14 00          Object size\n"
            + "00002 00002       02             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       08 00 00 00    Function main @ $0008 (local size 0)\n"
            + "' void main() {\n"
            + "'     do {\n"
            + "'         a++;\n"
            + "00008 00008       42             VAR_MODIFY LONG VBASE+$0000 (short)\n"
            + "00009 00009       2E             POST_INC\n"
            + "'     } until(a > 100);\n"
            + "0000A 0000A       40             VAR_READ LONG VBASE+$0000 (short)\n"
            + "0000B 0000B       38 64          CONSTANT (100)\n"
            + "0000D 0000D       FA             TEST_ABOVE\n"
            + "0000E 0000E       0A 78          JZ $00008 (-8)\n"
            + "' }\n"
            + "00010 00010       32             RETURN\n"
            + "00011 00011       00 00 00       Padding\n"
            + "", compile(text));
    }

    @Test
    void testConstants() throws Exception {
        String text = ""
            + "#define FREQ 160_000_000\n"
            + "\n"
            + "void main() {\n"
            + "    int a;\n"
            + "\n"
            + "    a = FREQ;\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 0)\n"
            + "00000 00000       10 00          Object size\n"
            + "00002 00002       02             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       08 00 04 00    Function main @ $0008 (local size 4)\n"
            + "' void main() {\n"
            + "'     a = FREQ;\n"
            + "00008 00008       3B 09 89 68 00 CONSTANT (160_000_000)\n"
            + "0000D 0000D       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "' }\n"
            + "0000E 0000E       32             RETURN\n"
            + "0000F 0000F       00             Padding\n"
            + "", compile(text));
    }

    @Test
    void testIf() throws Exception {
        String text = ""
            + "void main()\n"
            + "{\n"
            + "    int a;\n"
            + "\n"
            + "    if (a == 0) {\n"
            + "        a = 1;\n"
            + "    }\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 0)\n"
            + "00000 00000       10 00          Object size\n"
            + "00002 00002       02             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       08 00 04 00    Function main @ $0008 (local size 4)\n"
            + "' void main() {\n"
            + "'     if (a == 0) {\n"
            + "00008 00008       64             VAR_READ LONG DBASE+$0004 (short)\n"
            + "00009 00009       35             CONSTANT (0)\n"
            + "0000A 0000A       FC             TEST_EQUAL\n"
            + "0000B 0000B       0A 02          JZ $0000F (2)\n"
            + "'         a = 1;\n"
            + "0000D 0000D       36             CONSTANT (1)\n"
            + "0000E 0000E       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "'     }\n"
            + "' }\n"
            + "0000F 0000F       32             RETURN\n"
            + "", compile(text));
    }

    @Test
    void testIfElse() throws Exception {
        String text = ""
            + "void main()\n"
            + "{\n"
            + "    int a;\n"
            + "\n"
            + "    if (a == 0) {\n"
            + "        a = 1;\n"
            + "    }\n"
            + "    else {\n"
            + "        a = 2;\n"
            + "    }\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 0)\n"
            + "00000 00000       18 00          Object size\n"
            + "00002 00002       02             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       08 00 04 00    Function main @ $0008 (local size 4)\n"
            + "' void main() {\n"
            + "'     if (a == 0) {\n"
            + "00008 00008       64             VAR_READ LONG DBASE+$0004 (short)\n"
            + "00009 00009       35             CONSTANT (0)\n"
            + "0000A 0000A       FC             TEST_EQUAL\n"
            + "0000B 0000B       0A 04          JZ $00011 (4)\n"
            + "'         a = 1;\n"
            + "0000D 0000D       36             CONSTANT (1)\n"
            + "0000E 0000E       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "0000F 0000F       04 03          JMP $00014 (3)\n"
            + "'     }\n"
            + "'     else {\n"
            + "'         a = 2;\n"
            + "00011 00011       38 02          CONSTANT (2)\n"
            + "00013 00013       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "'     }\n"
            + "' }\n"
            + "00014 00014       32             RETURN\n"
            + "00015 00015       00 00 00       Padding\n"
            + "", compile(text));
    }

    @Test
    void testIfElseSimpleBlock() throws Exception {
        String text = ""
            + "void main()\n"
            + "{\n"
            + "    int a;\n"
            + "\n"
            + "    if (a == 0)\n"
            + "        a = 1;\n"
            + "    else\n"
            + "        a = 2;\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 0)\n"
            + "00000 00000       18 00          Object size\n"
            + "00002 00002       02             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       08 00 04 00    Function main @ $0008 (local size 4)\n"
            + "' void main() {\n"
            + "'     if (a == 0)\n"
            + "00008 00008       64             VAR_READ LONG DBASE+$0004 (short)\n"
            + "00009 00009       35             CONSTANT (0)\n"
            + "0000A 0000A       FC             TEST_EQUAL\n"
            + "0000B 0000B       0A 04          JZ $00011 (4)\n"
            + "'         a = 1;\n"
            + "0000D 0000D       36             CONSTANT (1)\n"
            + "0000E 0000E       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "0000F 0000F       04 03          JMP $00014 (3)\n"
            + "'     else\n"
            + "'         a = 2;\n"
            + "00011 00011       38 02          CONSTANT (2)\n"
            + "00013 00013       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "' }\n"
            + "00014 00014       32             RETURN\n"
            + "00015 00015       00 00 00       Padding\n"
            + "", compile(text));
    }

    @Test
    void testIfElseIf() throws Exception {
        String text = ""
            + "void main()\n"
            + "{\n"
            + "    int a;\n"
            + "\n"
            + "    if (a == 0) {\n"
            + "        a = 1;\n"
            + "    }\n"
            + "    else if (a == 1) {\n"
            + "        a = 2;\n"
            + "    }\n"
            + "    else if (a == 2) {\n"
            + "        a = 3;\n"
            + "    }\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 0)\n"
            + "00000 00000       28 00          Object size\n"
            + "00002 00002       02             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       08 00 04 00    Function main @ $0008 (local size 4)\n"
            + "' void main() {\n"
            + "'     if (a == 0) {\n"
            + "00008 00008       64             VAR_READ LONG DBASE+$0004 (short)\n"
            + "00009 00009       35             CONSTANT (0)\n"
            + "0000A 0000A       FC             TEST_EQUAL\n"
            + "0000B 0000B       0A 04          JZ $00011 (4)\n"
            + "'         a = 1;\n"
            + "0000D 0000D       36             CONSTANT (1)\n"
            + "0000E 0000E       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "0000F 0000F       04 13          JMP $00024 (19)\n"
            + "'     }\n"
            + "'     else if (a == 1) {\n"
            + "00011 00011       64             VAR_READ LONG DBASE+$0004 (short)\n"
            + "00012 00012       36             CONSTANT (1)\n"
            + "00013 00013       FC             TEST_EQUAL\n"
            + "00014 00014       0A 05          JZ $0001B (5)\n"
            + "'         a = 2;\n"
            + "00016 00016       38 02          CONSTANT (2)\n"
            + "00018 00018       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "00019 00019       04 09          JMP $00024 (9)\n"
            + "'     }\n"
            + "'     else if (a == 2) {\n"
            + "0001B 0001B       64             VAR_READ LONG DBASE+$0004 (short)\n"
            + "0001C 0001C       38 02          CONSTANT (2)\n"
            + "0001E 0001E       FC             TEST_EQUAL\n"
            + "0001F 0001F       0A 03          JZ $00024 (3)\n"
            + "'         a = 3;\n"
            + "00021 00021       38 03          CONSTANT (3)\n"
            + "00023 00023       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "'     }\n"
            + "' }\n"
            + "00024 00024       32             RETURN\n"
            + "00025 00025       00 00 00       Padding\n"
            + "", compile(text));
    }

    @Test
    void testIfElseIfElse() throws Exception {
        String text = ""
            + "void main()\n"
            + "{\n"
            + "    int a;\n"
            + "\n"
            + "    if (a == 0) {\n"
            + "        a = 1;\n"
            + "    }\n"
            + "    else if (a == 1) {\n"
            + "        a = 2;\n"
            + "    }\n"
            + "    else if (a == 2) {\n"
            + "        a = 3;\n"
            + "    }\n"
            + "    else {\n"
            + "        a = 4;\n"
            + "    }\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 0)\n"
            + "00000 00000       2C 00          Object size\n"
            + "00002 00002       02             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       08 00 04 00    Function main @ $0008 (local size 4)\n"
            + "' void main() {\n"
            + "'     if (a == 0) {\n"
            + "00008 00008       64             VAR_READ LONG DBASE+$0004 (short)\n"
            + "00009 00009       35             CONSTANT (0)\n"
            + "0000A 0000A       FC             TEST_EQUAL\n"
            + "0000B 0000B       0A 04          JZ $00011 (4)\n"
            + "'         a = 1;\n"
            + "0000D 0000D       36             CONSTANT (1)\n"
            + "0000E 0000E       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "0000F 0000F       04 18          JMP $00029 (24)\n"
            + "'     }\n"
            + "'     else if (a == 1) {\n"
            + "00011 00011       64             VAR_READ LONG DBASE+$0004 (short)\n"
            + "00012 00012       36             CONSTANT (1)\n"
            + "00013 00013       FC             TEST_EQUAL\n"
            + "00014 00014       0A 05          JZ $0001B (5)\n"
            + "'         a = 2;\n"
            + "00016 00016       38 02          CONSTANT (2)\n"
            + "00018 00018       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "00019 00019       04 0E          JMP $00029 (14)\n"
            + "'     }\n"
            + "'     else if (a == 2) {\n"
            + "0001B 0001B       64             VAR_READ LONG DBASE+$0004 (short)\n"
            + "0001C 0001C       38 02          CONSTANT (2)\n"
            + "0001E 0001E       FC             TEST_EQUAL\n"
            + "0001F 0001F       0A 05          JZ $00026 (5)\n"
            + "'         a = 3;\n"
            + "00021 00021       38 03          CONSTANT (3)\n"
            + "00023 00023       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "00024 00024       04 03          JMP $00029 (3)\n"
            + "'     }\n"
            + "'     else {\n"
            + "'         a = 4;\n"
            + "00026 00026       38 04          CONSTANT (4)\n"
            + "00028 00028       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "'     }\n"
            + "' }\n"
            + "00029 00029       32             RETURN\n"
            + "0002A 0002A       00 00          Padding\n"
            + "", compile(text));
    }

    @Test
    void testSwitch() throws Exception {
        String text = ""
            + "void main()\n"
            + "{\n"
            + "    int a;\n"
            + "    switch(a) {\n"
            + "        case 1:\n"
            + "            a = 4;\n"
            + "            break;\n"
            + "        case 2:\n"
            + "            a = 5;\n"
            + "            break;\n"
            + "        case 3:\n"
            + "            a = 6;\n"
            + "            break;\n"
            + "    }\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 0)\n"
            + "00000 00000       24 00          Object size\n"
            + "00002 00002       02             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       08 00 04 00    Function main @ $0008 (local size 4)\n"
            + "' void main() {\n"
            + "'     switch(a) {\n"
            + "00008 00008       38 23          ADDRESS ($0023)\n"
            + "0000A 0000A       64             VAR_READ LONG DBASE+$0004 (short)\n"
            + "0000B 0000B       36             CONSTANT (1)\n"
            + "0000C 0000C       0D 09          CASE-JMP $00017 (9)\n"
            + "0000E 0000E       38 02          CONSTANT (2)\n"
            + "00010 00010       0D 09          CASE-JMP $0001B (9)\n"
            + "00012 00012       38 03          CONSTANT (3)\n"
            + "00014 00014       0D 09          CASE-JMP $0001F (9)\n"
            + "00016 00016       0C             CASE_DONE\n"
            + "'             a = 4;\n"
            + "00017 00017       38 04          CONSTANT (4)\n"
            + "00019 00019       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "0001A 0001A       0C             CASE_DONE\n"
            + "'             a = 5;\n"
            + "0001B 0001B       38 05          CONSTANT (5)\n"
            + "0001D 0001D       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "0001E 0001E       0C             CASE_DONE\n"
            + "'             a = 6;\n"
            + "0001F 0001F       38 06          CONSTANT (6)\n"
            + "00021 00021       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "00022 00022       0C             CASE_DONE\n"
            + "'     }\n"
            + "' }\n"
            + "00023 00023       32             RETURN\n"
            + "", compile(text));
    }

    @Test
    void testSwitchDefault() throws Exception {
        String text = ""
            + "void main()\n"
            + "{\n"
            + "    int a;\n"
            + "    switch(a) {\n"
            + "        case 1:\n"
            + "            a = 4;\n"
            + "            break;\n"
            + "        case 2:\n"
            + "            a = 5;\n"
            + "            break;\n"
            + "        default:\n"
            + "            a = 6;\n"
            + "            break;\n"
            + "    }\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 0)\n"
            + "00000 00000       20 00          Object size\n"
            + "00002 00002       02             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       08 00 04 00    Function main @ $0008 (local size 4)\n"
            + "' void main() {\n"
            + "'     switch(a) {\n"
            + "00008 00008       38 1E          ADDRESS ($001E)\n"
            + "0000A 0000A       64             VAR_READ LONG DBASE+$0004 (short)\n"
            + "0000B 0000B       36             CONSTANT (1)\n"
            + "0000C 0000C       0D 08          CASE-JMP $00016 (8)\n"
            + "0000E 0000E       38 02          CONSTANT (2)\n"
            + "00010 00010       0D 08          CASE-JMP $0001A (8)\n"
            + "'             a = 6;\n"
            + "00012 00012       38 06          CONSTANT (6)\n"
            + "00014 00014       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "00015 00015       0C             CASE_DONE\n"
            + "'             a = 4;\n"
            + "00016 00016       38 04          CONSTANT (4)\n"
            + "00018 00018       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "00019 00019       0C             CASE_DONE\n"
            + "'             a = 5;\n"
            + "0001A 0001A       38 05          CONSTANT (5)\n"
            + "0001C 0001C       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "0001D 0001D       0C             CASE_DONE\n"
            + "'     }\n"
            + "' }\n"
            + "0001E 0001E       32             RETURN\n"
            + "0001F 0001F       00             Padding\n"
            + "", compile(text));
    }

    @Test
    void testSwitchCaseWithoutBreak() throws Exception {
        String text = ""
            + "void main()\n"
            + "{\n"
            + "    int a;\n"
            + "    switch(a) {\n"
            + "        case 1:\n"
            + "            a = 4;\n"
            + "        case 2:\n"
            + "            a = 5;\n"
            + "        case 3:\n"
            + "            a = 6;\n"
            + "            break;\n"
            + "    }\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 0)\n"
            + "00000 00000       24 00          Object size\n"
            + "00002 00002       02             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       08 00 04 00    Function main @ $0008 (local size 4)\n"
            + "' void main() {\n"
            + "'     switch(a) {\n"
            + "00008 00008       38 21          ADDRESS ($0021)\n"
            + "0000A 0000A       64             VAR_READ LONG DBASE+$0004 (short)\n"
            + "0000B 0000B       36             CONSTANT (1)\n"
            + "0000C 0000C       0D 09          CASE-JMP $00017 (9)\n"
            + "0000E 0000E       38 02          CONSTANT (2)\n"
            + "00010 00010       0D 08          CASE-JMP $0001A (8)\n"
            + "00012 00012       38 03          CONSTANT (3)\n"
            + "00014 00014       0D 07          CASE-JMP $0001D (7)\n"
            + "00016 00016       0C             CASE_DONE\n"
            + "'             a = 4;\n"
            + "00017 00017       38 04          CONSTANT (4)\n"
            + "00019 00019       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "'             a = 5;\n"
            + "0001A 0001A       38 05          CONSTANT (5)\n"
            + "0001C 0001C       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "'             a = 6;\n"
            + "0001D 0001D       38 06          CONSTANT (6)\n"
            + "0001F 0001F       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "00020 00020       0C             CASE_DONE\n"
            + "'     }\n"
            + "' }\n"
            + "00021 00021       32             RETURN\n"
            + "00022 00022       00 00          Padding\n"
            + "", compile(text));
    }

    @Test
    void testSwitchCaseWithoutStatements() throws Exception {
        String text = ""
            + "void main()\n"
            + "{\n"
            + "    int a;\n"
            + "    switch(a) {\n"
            + "        case 1:\n"
            + "        case 2:\n"
            + "            a = 5;\n"
            + "            break;\n"
            + "        case 3:\n"
            + "            a = 6;\n"
            + "            break;\n"
            + "    }\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 0)\n"
            + "00000 00000       20 00          Object size\n"
            + "00002 00002       02             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       08 00 04 00    Function main @ $0008 (local size 4)\n"
            + "' void main() {\n"
            + "'     switch(a) {\n"
            + "00008 00008       38 1F          ADDRESS ($001F)\n"
            + "0000A 0000A       64             VAR_READ LONG DBASE+$0004 (short)\n"
            + "0000B 0000B       36             CONSTANT (1)\n"
            + "0000C 0000C       0D 09          CASE-JMP $00017 (9)\n"
            + "0000E 0000E       38 02          CONSTANT (2)\n"
            + "00010 00010       0D 05          CASE-JMP $00017 (5)\n"
            + "00012 00012       38 03          CONSTANT (3)\n"
            + "00014 00014       0D 05          CASE-JMP $0001B (5)\n"
            + "00016 00016       0C             CASE_DONE\n"
            + "'             a = 5;\n"
            + "00017 00017       38 05          CONSTANT (5)\n"
            + "00019 00019       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "0001A 0001A       0C             CASE_DONE\n"
            + "'             a = 6;\n"
            + "0001B 0001B       38 06          CONSTANT (6)\n"
            + "0001D 0001D       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "0001E 0001E       0C             CASE_DONE\n"
            + "'     }\n"
            + "' }\n"
            + "0001F 0001F       32             RETURN\n"
            + "", compile(text));
    }

    @Test
    void testSwitchCaseWithSpinSyntax() throws Exception {
        String text = ""
            + "void main()\n"
            + "{\n"
            + "    int a;\n"
            + "    switch(a) {\n"
            + "        case 1, 2:\n"
            + "            a = 5;\n"
            + "            break;\n"
            + "        case 3..5,7,8:\n"
            + "            a = 6;\n"
            + "            break;\n"
            + "    }\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 0)\n"
            + "00000 00000       2C 00          Object size\n"
            + "00002 00002       02             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       08 00 04 00    Function main @ $0008 (local size 4)\n"
            + "' void main() {\n"
            + "'     switch(a) {\n"
            + "00008 00008       38 29          ADDRESS ($0029)\n"
            + "0000A 0000A       64             VAR_READ LONG DBASE+$0004 (short)\n"
            + "0000B 0000B       36             CONSTANT (1)\n"
            + "0000C 0000C       0D 13          CASE-JMP $00021 (19)\n"
            + "0000E 0000E       38 02          CONSTANT (2)\n"
            + "00010 00010       0D 0F          CASE-JMP $00021 (15)\n"
            + "00012 00012       38 03          CONSTANT (3)\n"
            + "00014 00014       38 05          CONSTANT (5)\n"
            + "00016 00016       0E 0D          CASE-RANGE-JMP $00025 (13)\n"
            + "00018 00018       38 07          CONSTANT (7)\n"
            + "0001A 0001A       0D 09          CASE-JMP $00025 (9)\n"
            + "0001C 0001C       38 08          CONSTANT (8)\n"
            + "0001E 0001E       0D 05          CASE-JMP $00025 (5)\n"
            + "00020 00020       0C             CASE_DONE\n"
            + "'             a = 5;\n"
            + "00021 00021       38 05          CONSTANT (5)\n"
            + "00023 00023       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "00024 00024       0C             CASE_DONE\n"
            + "'             a = 6;\n"
            + "00025 00025       38 06          CONSTANT (6)\n"
            + "00027 00027       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "00028 00028       0C             CASE_DONE\n"
            + "'     }\n"
            + "' }\n"
            + "00029 00029       32             RETURN\n"
            + "0002A 0002A       00 00          Padding\n"
            + "", compile(text));
    }

    @Test
    void testPreprocessorNotDefined() throws Exception {
        String text = ""
            + "void main(int a)\n"
            + "{\n"
            + "#ifdef TEST\n"
            + "    a = 1;\n"
            + "#endif\n"
            + "    a++;\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 0)\n"
            + "00000 00000       0C 00          Object size\n"
            + "00002 00002       02             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       08 00 00 00    Function main @ $0008 (local size 0)\n"
            + "' void main(int a) {\n"
            + "'     a++;\n"
            + "00008 00008       66             VAR_MODIFY LONG DBASE+$0004 (short)\n"
            + "00009 00009       2E             POST_INC\n"
            + "' }\n"
            + "0000A 0000A       32             RETURN\n"
            + "0000B 0000B       00             Padding\n"
            + "", compile(text));
    }

    @Test
    void testPreprocessorDefined() throws Exception {
        String text = ""
            + "#define TEST\n"
            + "\n"
            + "void main(int a)\n"
            + "{\n"
            + "#ifdef TEST\n"
            + "    a = 1;\n"
            + "#endif\n"
            + "    a++;\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 0)\n"
            + "00000 00000       10 00          Object size\n"
            + "00002 00002       02             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       08 00 00 00    Function main @ $0008 (local size 0)\n"
            + "' void main(int a) {\n"
            + "'     a = 1;\n"
            + "00008 00008       36             CONSTANT (1)\n"
            + "00009 00009       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "'     a++;\n"
            + "0000A 0000A       66             VAR_MODIFY LONG DBASE+$0004 (short)\n"
            + "0000B 0000B       2E             POST_INC\n"
            + "' }\n"
            + "0000C 0000C       32             RETURN\n"
            + "0000D 0000D       00 00 00       Padding\n"
            + "", compile(text));
    }

    @Test
    void testPreprocessorNotDefinedElse() throws Exception {
        String text = ""
            + "void main(int a)\n"
            + "{\n"
            + "#ifdef TEST\n"
            + "    a = 1;\n"
            + "#else\n"
            + "    a = 2;\n"
            + "#endif\n"
            + "    a++;\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 0)\n"
            + "00000 00000       10 00          Object size\n"
            + "00002 00002       02             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       08 00 00 00    Function main @ $0008 (local size 0)\n"
            + "' void main(int a) {\n"
            + "'     a = 2;\n"
            + "00008 00008       38 02          CONSTANT (2)\n"
            + "0000A 0000A       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "'     a++;\n"
            + "0000B 0000B       66             VAR_MODIFY LONG DBASE+$0004 (short)\n"
            + "0000C 0000C       2E             POST_INC\n"
            + "' }\n"
            + "0000D 0000D       32             RETURN\n"
            + "0000E 0000E       00 00          Padding\n"
            + "", compile(text));
    }

    @Test
    void testNestedPreprocessorNotDefinedElse1() throws Exception {
        String text = ""
            + "void main(int a)\n"
            + "{\n"
            + "#ifndef P2\n"
            + "  #ifdef TEST\n"
            + "    a = 1;\n"
            + "  #else\n"
            + "    a = 2;\n"
            + "  #endif\n"
            + "    a++;\n"
            + "#endif\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 0)\n"
            + "00000 00000       10 00          Object size\n"
            + "00002 00002       02             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       08 00 00 00    Function main @ $0008 (local size 0)\n"
            + "' void main(int a) {\n"
            + "'     a = 2;\n"
            + "00008 00008       38 02          CONSTANT (2)\n"
            + "0000A 0000A       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "'     a++;\n"
            + "0000B 0000B       66             VAR_MODIFY LONG DBASE+$0004 (short)\n"
            + "0000C 0000C       2E             POST_INC\n"
            + "' }\n"
            + "0000D 0000D       32             RETURN\n"
            + "0000E 0000E       00 00          Padding\n"
            + "", compile(text));
    }

    @Test
    void testNestedPreprocessorNotDefinedElse2() throws Exception {
        String text = ""
            + "#define TEST\n"
            + "\n"
            + "void main(int a)\n"
            + "{\n"
            + "#ifndef P2\n"
            + "  #ifdef TEST\n"
            + "    a = 1;\n"
            + "  #else\n"
            + "    a = 2;\n"
            + "  #endif\n"
            + "    a++;\n"
            + "#endif\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 0)\n"
            + "00000 00000       10 00          Object size\n"
            + "00002 00002       02             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       08 00 00 00    Function main @ $0008 (local size 0)\n"
            + "' void main(int a) {\n"
            + "'     a = 1;\n"
            + "00008 00008       36             CONSTANT (1)\n"
            + "00009 00009       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "'     a++;\n"
            + "0000A 0000A       66             VAR_MODIFY LONG DBASE+$0004 (short)\n"
            + "0000B 0000B       2E             POST_INC\n"
            + "' }\n"
            + "0000C 0000C       32             RETURN\n"
            + "0000D 0000D       00 00 00       Padding\n"
            + "", compile(text));
    }

    @Test
    void testPreprocessorIf() throws Exception {
        String text = ""
            + "#define TEST 1\n"
            + "\n"
            + "void main(int a)\n"
            + "{\n"
            + "#if defined(__P2__)\n"
            + "  #if TEST\n"
            + "    a = 1;\n"
            + "  #else\n"
            + "    a = 2;\n"
            + "  #endif\n"
            + "    a++;\n"
            + "#endif\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 0)\n"
            + "00000 00000       10 00          Object size\n"
            + "00002 00002       02             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       08 00 00 00    Function main @ $0008 (local size 0)\n"
            + "' void main(int a) {\n"
            + "'     a = 1;\n"
            + "00008 00008       36             CONSTANT (1)\n"
            + "00009 00009       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "'     a++;\n"
            + "0000A 0000A       66             VAR_MODIFY LONG DBASE+$0004 (short)\n"
            + "0000B 0000B       2E             POST_INC\n"
            + "' }\n"
            + "0000C 0000C       32             RETURN\n"
            + "0000D 0000D       00 00 00       Padding\n"
            + "", compile(text));
    }

    @Test
    void testBytePointer() throws Exception {
        String text = ""
            + "byte * ptr, a, *b;\n"
            + "\n"
            + "void main()\n"
            + "{\n"
            + "    ptr = \"Hello, World!\";\n"
            + "    a = 'a';\n"
            + "    b = \"b\";\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 12)\n"
            + "00000 00000       24 00          Object size\n"
            + "00002 00002       02             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       08 00 00 00    Function main @ $0008 (local size 0)\n"
            + "' void main() {\n"
            + "'     ptr = \"Hello, World!\";\n"
            + "00008 00008       87 13          MEM_ADDRESS BYTE PBASE+$0013\n"
            + "0000A 0000A       41             VAR_WRITE LONG VBASE+$0000 (short)\n"
            + "'     a = 'a';\n"
            + "0000B 0000B       38 61          CONSTANT (\"a\")\n"
            + "0000D 0000D       89 04          VAR_WRITE BYTE VBASE+$0004\n"
            + "'     b = \"b\";\n"
            + "0000F 0000F       87 21          MEM_ADDRESS BYTE PBASE+$0021\n"
            + "00011 00011       49             VAR_WRITE LONG VBASE+$0008 (short)\n"
            + "' }\n"
            + "00012 00012       32             RETURN\n"
            + "' (string data)\n"
            + "00013 00013       48 65 6C 6C 6F STRING\n"
            + "00018 00018       2C 20 57 6F 72\n"
            + "0001D 0001D       6C 64 21 00\n"
            + "00021 00021       62 00          STRING\n"
            + "00023 00023       00             Padding\n"
            + "", compile(text));
    }

    @Test
    void testBytePointerStatements() throws Exception {
        String text = ""
            + "void main()\n"
            + "{\n"
            + "    byte * ptr, a, *b;\n"
            + "\n"
            + "    ptr = \"Hello, World!\";\n"
            + "    a = 'a';\n"
            + "    b = \"b\";\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 0)\n"
            + "00000 00000       24 00          Object size\n"
            + "00002 00002       02             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       08 00 0C 00    Function main @ $0008 (local size 12)\n"
            + "' void main() {\n"
            + "'     ptr = \"Hello, World!\";\n"
            + "00008 00008       87 13          MEM_ADDRESS BYTE PBASE+$0013\n"
            + "0000A 0000A       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "'     a = 'a';\n"
            + "0000B 0000B       38 61          CONSTANT (\"a\")\n"
            + "0000D 0000D       8D 08          VAR_WRITE BYTE DBASE+$0008\n"
            + "'     b = \"b\";\n"
            + "0000F 0000F       87 21          MEM_ADDRESS BYTE PBASE+$0021\n"
            + "00011 00011       6D             VAR_WRITE LONG DBASE+$000C (short)\n"
            + "' }\n"
            + "00012 00012       32             RETURN\n"
            + "' (string data)\n"
            + "00013 00013       48 65 6C 6C 6F STRING\n"
            + "00018 00018       2C 20 57 6F 72\n"
            + "0001D 0001D       6C 64 21 00\n"
            + "00021 00021       62 00          STRING\n"
            + "00023 00023       00             Padding\n"
            + "", compile(text));
    }

    @Test
    void testBytePointerArgument() throws Exception {
        String text = ""
            + "void main()\n"
            + "{\n"
            + "    str(\"Hello, World!\");\n"
            + "}\n"
            + "\n"
            + "void str(byte * ptr)\n"
            + "{\n"
            + "\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 0)\n"
            + "00000 00000       24 00          Object size\n"
            + "00002 00002       03             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       0C 00 00 00    Function main @ $000C (local size 0)\n"
            + "00008 00008       12 00 00 00    Function str @ $0012 (local size 0)\n"
            + "' void main() {\n"
            + "'     str(\"Hello, World!\");\n"
            + "0000C 0000C       01             ANCHOR\n"
            + "0000D 0000D       87 13          MEM_ADDRESS BYTE PBASE+$0013\n"
            + "0000F 0000F       05 02          CALL_SUB (1)\n"
            + "' }\n"
            + "00011 00011       32             RETURN\n"
            + "' void str(byte * ptr) {\n"
            + "' }\n"
            + "00012 00012       32             RETURN\n"
            + "' (string data)\n"
            + "00013 00013       48 65 6C 6C 6F STRING\n"
            + "00018 00018       2C 20 57 6F 72\n"
            + "0001D 0001D       6C 64 21 00\n"
            + "00021 00021       00 00 00       Padding\n"
            + "", compile(text));
    }

    @Test
    void testPointerDereference() throws Exception {
        String text = ""
            + "void main()\n"
            + "{\n"
            + "    int a;\n"
            + "    byte * ptr1;\n"
            + "    word * ptr2;\n"
            + "    int * ptr3;\n"
            + "\n"
            + "    a = *ptr1;\n"
            + "    a = *ptr2;\n"
            + "    a = *ptr3;\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 0)\n"
            + "00000 00000       14 00          Object size\n"
            + "00002 00002       02             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       08 00 10 00    Function main @ $0008 (local size 16)\n"
            + "' void main() {\n"
            + "'     a = *ptr1;\n"
            + "00008 00008       68             VAR_READ LONG DBASE+$0008 (short)\n"
            + "00009 00009       80             MEM_READ BYTE POP\n"
            + "0000A 0000A       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "'     a = *ptr2;\n"
            + "0000B 0000B       6C             VAR_READ LONG DBASE+$000C (short)\n"
            + "0000C 0000C       A0             MEM_READ WORD POP\n"
            + "0000D 0000D       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "'     a = *ptr3;\n"
            + "0000E 0000E       70             VAR_READ LONG DBASE+$0010 (short)\n"
            + "0000F 0000F       C0             MEM_READ LONG POP\n"
            + "00010 00010       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "' }\n"
            + "00011 00011       32             RETURN\n"
            + "00012 00012       00 00          Padding\n"
            + "", compile(text));
    }

    @Test
    void testPointerDereferenceAssign() throws Exception {
        String text = ""
            + "void main()\n"
            + "{\n"
            + "    int a;\n"
            + "    byte * ptr1;\n"
            + "    word * ptr2;\n"
            + "    int * ptr3;\n"
            + "\n"
            + "    *ptr1 = a;\n"
            + "    *ptr2 = a;\n"
            + "    *ptr3 = a;\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 0)\n"
            + "00000 00000       14 00          Object size\n"
            + "00002 00002       02             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       08 00 10 00    Function main @ $0008 (local size 16)\n"
            + "' void main() {\n"
            + "'     *ptr1 = a;\n"
            + "00008 00008       64             VAR_READ LONG DBASE+$0004 (short)\n"
            + "00009 00009       68             VAR_READ LONG DBASE+$0008 (short)\n"
            + "0000A 0000A       81             MEM_WRITE BYTE POP\n"
            + "'     *ptr2 = a;\n"
            + "0000B 0000B       64             VAR_READ LONG DBASE+$0004 (short)\n"
            + "0000C 0000C       6C             VAR_READ LONG DBASE+$000C (short)\n"
            + "0000D 0000D       A1             MEM_WRITE WORD POP\n"
            + "'     *ptr3 = a;\n"
            + "0000E 0000E       64             VAR_READ LONG DBASE+$0004 (short)\n"
            + "0000F 0000F       70             VAR_READ LONG DBASE+$0010 (short)\n"
            + "00010 00010       C1             MEM_WRITE LONG POP\n"
            + "' }\n"
            + "00011 00011       32             RETURN\n"
            + "00012 00012       00 00          Padding\n"
            + "", compile(text));
    }

    @Test
    void testPointerDereferencePostEffect() throws Exception {
        String text = ""
            + "void main()\n"
            + "{\n"
            + "    int a;\n"
            + "    byte * ptr1;\n"
            + "    word * ptr2;\n"
            + "    int * ptr3;\n"
            + "\n"
            + "    a = *ptr1++;\n"
            + "    a = *ptr2++;\n"
            + "    a = *ptr3++;\n"
            + "\n"
            + "    a = *ptr1--;\n"
            + "    a = *ptr2--;\n"
            + "    a = *ptr3--;\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 0)\n"
            + "00000 00000       30 00          Object size\n"
            + "00002 00002       02             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       08 00 10 00    Function main @ $0008 (local size 16)\n"
            + "' void main() {\n"
            + "'     a = *ptr1++;\n"
            + "00008 00008       6A             VAR_MODIFY LONG DBASE+$0008 (short)\n"
            + "00009 00009       AE             POST_INC\n"
            + "0000A 0000A       80             MEM_READ BYTE POP\n"
            + "0000B 0000B       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "'     a = *ptr2++;\n"
            + "0000C 0000C       6C             VAR_READ LONG DBASE+$000C (short)\n"
            + "0000D 0000D       38 02          CONSTANT (2)\n"
            + "0000F 0000F       6E             VAR_MODIFY LONG DBASE+$000C (short)\n"
            + "00010 00010       4C             ADD\n"
            + "00011 00011       A0             MEM_READ WORD POP\n"
            + "00012 00012       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "'     a = *ptr3++;\n"
            + "00013 00013       70             VAR_READ LONG DBASE+$0010 (short)\n"
            + "00014 00014       38 04          CONSTANT (4)\n"
            + "00016 00016       72             VAR_MODIFY LONG DBASE+$0010 (short)\n"
            + "00017 00017       4C             ADD\n"
            + "00018 00018       C0             MEM_READ LONG POP\n"
            + "00019 00019       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "'     a = *ptr1--;\n"
            + "0001A 0001A       6A             VAR_MODIFY LONG DBASE+$0008 (short)\n"
            + "0001B 0001B       BE             POST_DEC\n"
            + "0001C 0001C       80             MEM_READ BYTE POP\n"
            + "0001D 0001D       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "'     a = *ptr2--;\n"
            + "0001E 0001E       6C             VAR_READ LONG DBASE+$000C (short)\n"
            + "0001F 0001F       38 02          CONSTANT (2)\n"
            + "00021 00021       6E             VAR_MODIFY LONG DBASE+$000C (short)\n"
            + "00022 00022       4D             SUBTRACT\n"
            + "00023 00023       A0             MEM_READ WORD POP\n"
            + "00024 00024       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "'     a = *ptr3--;\n"
            + "00025 00025       70             VAR_READ LONG DBASE+$0010 (short)\n"
            + "00026 00026       38 04          CONSTANT (4)\n"
            + "00028 00028       72             VAR_MODIFY LONG DBASE+$0010 (short)\n"
            + "00029 00029       4D             SUBTRACT\n"
            + "0002A 0002A       C0             MEM_READ LONG POP\n"
            + "0002B 0002B       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "' }\n"
            + "0002C 0002C       32             RETURN\n"
            + "0002D 0002D       00 00 00       Padding\n"
            + "", compile(text));
    }

    @Test
    void testPointerDereferencePostEffectAssign() throws Exception {
        String text = ""
            + "void main()\n"
            + "{\n"
            + "    int a;\n"
            + "    byte * ptr1;\n"
            + "    word * ptr2;\n"
            + "    int * ptr3;\n"
            + "\n"
            + "    *ptr1++ = a;\n"
            + "    *ptr2++ = a;\n"
            + "    *ptr3++ = a;\n"
            + "\n"
            + "    *ptr1-- = a;\n"
            + "    *ptr2-- = a;\n"
            + "    *ptr3-- = a;\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 0)\n"
            + "00000 00000       30 00          Object size\n"
            + "00002 00002       02             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       08 00 10 00    Function main @ $0008 (local size 16)\n"
            + "' void main() {\n"
            + "'     *ptr1++ = a;\n"
            + "00008 00008       64             VAR_READ LONG DBASE+$0004 (short)\n"
            + "00009 00009       6A             VAR_MODIFY LONG DBASE+$0008 (short)\n"
            + "0000A 0000A       AE             POST_INC\n"
            + "0000B 0000B       81             MEM_WRITE BYTE POP\n"
            + "'     *ptr2++ = a;\n"
            + "0000C 0000C       64             VAR_READ LONG DBASE+$0004 (short)\n"
            + "0000D 0000D       6C             VAR_READ LONG DBASE+$000C (short)\n"
            + "0000E 0000E       38 02          CONSTANT (2)\n"
            + "00010 00010       6E             VAR_MODIFY LONG DBASE+$000C (short)\n"
            + "00011 00011       4C             ADD\n"
            + "00012 00012       A1             MEM_WRITE WORD POP\n"
            + "'     *ptr3++ = a;\n"
            + "00013 00013       64             VAR_READ LONG DBASE+$0004 (short)\n"
            + "00014 00014       70             VAR_READ LONG DBASE+$0010 (short)\n"
            + "00015 00015       38 04          CONSTANT (4)\n"
            + "00017 00017       72             VAR_MODIFY LONG DBASE+$0010 (short)\n"
            + "00018 00018       4C             ADD\n"
            + "00019 00019       C1             MEM_WRITE LONG POP\n"
            + "'     *ptr1-- = a;\n"
            + "0001A 0001A       64             VAR_READ LONG DBASE+$0004 (short)\n"
            + "0001B 0001B       6A             VAR_MODIFY LONG DBASE+$0008 (short)\n"
            + "0001C 0001C       BE             POST_DEC\n"
            + "0001D 0001D       81             MEM_WRITE BYTE POP\n"
            + "'     *ptr2-- = a;\n"
            + "0001E 0001E       64             VAR_READ LONG DBASE+$0004 (short)\n"
            + "0001F 0001F       6C             VAR_READ LONG DBASE+$000C (short)\n"
            + "00020 00020       38 02          CONSTANT (2)\n"
            + "00022 00022       6E             VAR_MODIFY LONG DBASE+$000C (short)\n"
            + "00023 00023       4D             SUBTRACT\n"
            + "00024 00024       A1             MEM_WRITE WORD POP\n"
            + "'     *ptr3-- = a;\n"
            + "00025 00025       64             VAR_READ LONG DBASE+$0004 (short)\n"
            + "00026 00026       70             VAR_READ LONG DBASE+$0010 (short)\n"
            + "00027 00027       38 04          CONSTANT (4)\n"
            + "00029 00029       72             VAR_MODIFY LONG DBASE+$0010 (short)\n"
            + "0002A 0002A       4D             SUBTRACT\n"
            + "0002B 0002B       C1             MEM_WRITE LONG POP\n"
            + "' }\n"
            + "0002C 0002C       32             RETURN\n"
            + "0002D 0002D       00 00 00       Padding\n"
            + "", compile(text));
    }

    @Test
    void testPointerArray() throws Exception {
        String text = ""
            + "void main()\n"
            + "{\n"
            + "    int a, b;\n"
            + "    byte * ptr1;\n"
            + "    word * ptr2;\n"
            + "    int * ptr3;\n"
            + "\n"
            + "    a = ptr1[0];\n"
            + "    a = ptr2[1];\n"
            + "    a = ptr3[2];\n"
            + "\n"
            + "    a = ptr1[b+0];\n"
            + "    a = ptr2[b+1];\n"
            + "    a = ptr3[b+2];\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 0)\n"
            + "00000 00000       2C 00          Object size\n"
            + "00002 00002       02             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       08 00 14 00    Function main @ $0008 (local size 20)\n"
            + "' void main() {\n"
            + "'     a = ptr1[0];\n"
            + "00008 00008       6C             VAR_READ LONG DBASE+$000C (short)\n"
            + "00009 00009       35             CONSTANT (0)\n"
            + "0000A 0000A       90             MEM_READ_INDEXED BYTE POP\n"
            + "0000B 0000B       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "'     a = ptr2[1];\n"
            + "0000C 0000C       70             VAR_READ LONG DBASE+$0010 (short)\n"
            + "0000D 0000D       36             CONSTANT (1)\n"
            + "0000E 0000E       B0             MEM_READ_INDEXED WORD POP\n"
            + "0000F 0000F       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "'     a = ptr3[2];\n"
            + "00010 00010       74             VAR_READ LONG DBASE+$0014 (short)\n"
            + "00011 00011       38 02          CONSTANT (2)\n"
            + "00013 00013       D0             MEM_READ_INDEXED LONG POP\n"
            + "00014 00014       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "'     a = ptr1[b+0];\n"
            + "00015 00015       6C             VAR_READ LONG DBASE+$000C (short)\n"
            + "00016 00016       68             VAR_READ LONG DBASE+$0008 (short)\n"
            + "00017 00017       35             CONSTANT (0)\n"
            + "00018 00018       EC             ADD\n"
            + "00019 00019       90             MEM_READ_INDEXED BYTE POP\n"
            + "0001A 0001A       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "'     a = ptr2[b+1];\n"
            + "0001B 0001B       70             VAR_READ LONG DBASE+$0010 (short)\n"
            + "0001C 0001C       68             VAR_READ LONG DBASE+$0008 (short)\n"
            + "0001D 0001D       36             CONSTANT (1)\n"
            + "0001E 0001E       EC             ADD\n"
            + "0001F 0001F       B0             MEM_READ_INDEXED WORD POP\n"
            + "00020 00020       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "'     a = ptr3[b+2];\n"
            + "00021 00021       74             VAR_READ LONG DBASE+$0014 (short)\n"
            + "00022 00022       68             VAR_READ LONG DBASE+$0008 (short)\n"
            + "00023 00023       38 02          CONSTANT (2)\n"
            + "00025 00025       EC             ADD\n"
            + "00026 00026       D0             MEM_READ_INDEXED LONG POP\n"
            + "00027 00027       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "' }\n"
            + "00028 00028       32             RETURN\n"
            + "00029 00029       00 00 00       Padding\n"
            + "", compile(text));
    }

    @Test
    void testPointerArrayAssign() throws Exception {
        String text = ""
            + "void main()\n"
            + "{\n"
            + "    int a;\n"
            + "    byte * ptr1;\n"
            + "    word * ptr2;\n"
            + "    int * ptr3;\n"
            + "\n"
            + "    ptr1[0] = a;\n"
            + "    ptr2[1] = a;\n"
            + "    ptr3[2] = a;\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 0)\n"
            + "00000 00000       18 00          Object size\n"
            + "00002 00002       02             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       08 00 10 00    Function main @ $0008 (local size 16)\n"
            + "' void main() {\n"
            + "'     ptr1[0] = a;\n"
            + "00008 00008       64             VAR_READ LONG DBASE+$0004 (short)\n"
            + "00009 00009       68             VAR_READ LONG DBASE+$0008 (short)\n"
            + "0000A 0000A       35             CONSTANT (0)\n"
            + "0000B 0000B       91             MEM_WRITE_INDEXED BYTE POP\n"
            + "'     ptr2[1] = a;\n"
            + "0000C 0000C       64             VAR_READ LONG DBASE+$0004 (short)\n"
            + "0000D 0000D       6C             VAR_READ LONG DBASE+$000C (short)\n"
            + "0000E 0000E       36             CONSTANT (1)\n"
            + "0000F 0000F       B1             MEM_WRITE_INDEXED WORD POP\n"
            + "'     ptr3[2] = a;\n"
            + "00010 00010       64             VAR_READ LONG DBASE+$0004 (short)\n"
            + "00011 00011       70             VAR_READ LONG DBASE+$0010 (short)\n"
            + "00012 00012       38 02          CONSTANT (2)\n"
            + "00014 00014       D1             MEM_WRITE_INDEXED LONG POP\n"
            + "' }\n"
            + "00015 00015       32             RETURN\n"
            + "00016 00016       00 00          Padding\n"
            + "", compile(text));
    }

    @Test
    void testStructure() throws Exception {
        String text = ""
            + "struct _s {\n"
            + "    byte a;\n"
            + "    word b;\n"
            + "    word c;\n"
            + "    long d;\n"
            + "};\n"
            + "\n"
            + "struct _s s;\n"
            + "\n"
            + "void main()\n"
            + "{\n"
            + "    int a;\n"
            + "\n"
            + "    s.a = a;\n"
            + "    s.b = a;\n"
            + "    s.c = a;\n"
            + "    s.d = a;\n"
            + "\n"
            + "    a = s.a;\n"
            + "    a = s.b;\n"
            + "    a = s.c;\n"
            + "    a = s.d;\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 12)\n"
            + "00000 00000       20 00          Object size\n"
            + "00002 00002       02             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       08 00 04 00    Function main @ $0008 (local size 4)\n"
            + "' void main() {\n"
            + "'     s.a = a;\n"
            + "00008 00008       64             VAR_READ LONG DBASE+$0004 (short)\n"
            + "00009 00009       89 00          VAR_WRITE BYTE VBASE+$0000\n"
            + "'     s.b = a;\n"
            + "0000B 0000B       64             VAR_READ LONG DBASE+$0004 (short)\n"
            + "0000C 0000C       A9 02          VAR_WRITE WORD VBASE+$0002\n"
            + "'     s.c = a;\n"
            + "0000E 0000E       64             VAR_READ LONG DBASE+$0004 (short)\n"
            + "0000F 0000F       A9 04          VAR_WRITE WORD VBASE+$0004\n"
            + "'     s.d = a;\n"
            + "00011 00011       64             VAR_READ LONG DBASE+$0004 (short)\n"
            + "00012 00012       49             VAR_WRITE LONG VBASE+$0008 (short)\n"
            + "'     a = s.a;\n"
            + "00013 00013       88 00          VAR_READ BYTE VBASE+$0000\n"
            + "00015 00015       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "'     a = s.b;\n"
            + "00016 00016       A8 02          VAR_READ WORD VBASE+$0002\n"
            + "00018 00018       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "'     a = s.c;\n"
            + "00019 00019       A8 04          VAR_READ WORD VBASE+$0004\n"
            + "0001B 0001B       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "'     a = s.d;\n"
            + "0001C 0001C       48             VAR_READ LONG VBASE+$0008 (short)\n"
            + "0001D 0001D       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "' }\n"
            + "0001E 0001E       32             RETURN\n"
            + "0001F 0001F       00             Padding\n"
            + "", compile(text));
    }

    @Test
    void testStructureArray() throws Exception {
        String text = ""
            + "struct _s {\n"
            + "    byte a;\n"
            + "    word b;\n"
            + "    word c;\n"
            + "    long d;\n"
            + "};\n"
            + "\n"
            + "struct _s s[2];\n"
            + "\n"
            + "void main()\n"
            + "{\n"
            + "    int a;\n"
            + "\n"
            + "    s[1].a = a;\n"
            + "    s[1].b = a;\n"
            + "    s[1].c = a;\n"
            + "    s[1].d = a;\n"
            + "\n"
            + "    a = s[1].a;\n"
            + "    a = s[1].b;\n"
            + "    a = s[1].c;\n"
            + "    a = s[1].d;\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 24)\n"
            + "00000 00000       40 00          Object size\n"
            + "00002 00002       02             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       08 00 04 00    Function main @ $0008 (local size 4)\n"
            + "' void main() {\n"
            + "'     s[1].a = a;\n"
            + "00008 00008       64             VAR_READ LONG DBASE+$0004 (short)\n"
            + "00009 00009       38 0C          CONSTANT (1 * 12)\n"
            + "0000B 0000B       8B 00          VAR_ADDRESS VBASE+$0000\n"
            + "0000D 0000D       EC             ADD\n"
            + "0000E 0000E       81             MEM_WRITE BYTE POP\n"
            + "'     s[1].b = a;\n"
            + "0000F 0000F       64             VAR_READ LONG DBASE+$0004 (short)\n"
            + "00010 00010       38 0C          CONSTANT (1 * 12)\n"
            + "00012 00012       AB 02          VAR_ADDRESS VBASE+$0002\n"
            + "00014 00014       EC             ADD\n"
            + "00015 00015       A1             MEM_WRITE WORD POP\n"
            + "'     s[1].c = a;\n"
            + "00016 00016       64             VAR_READ LONG DBASE+$0004 (short)\n"
            + "00017 00017       38 0C          CONSTANT (1 * 12)\n"
            + "00019 00019       AB 04          VAR_ADDRESS VBASE+$0004\n"
            + "0001B 0001B       EC             ADD\n"
            + "0001C 0001C       A1             MEM_WRITE WORD POP\n"
            + "'     s[1].d = a;\n"
            + "0001D 0001D       64             VAR_READ LONG DBASE+$0004 (short)\n"
            + "0001E 0001E       38 0C          CONSTANT (1 * 12)\n"
            + "00020 00020       4B             VAR_ADDRESS VBASE+$0008 (short)\n"
            + "00021 00021       EC             ADD\n"
            + "00022 00022       C1             MEM_WRITE LONG POP\n"
            + "'     a = s[1].a;\n"
            + "00023 00023       38 0C          CONSTANT (1 * 12)\n"
            + "00025 00025       8B 00          VAR_ADDRESS VBASE+$0000\n"
            + "00027 00027       EC             ADD\n"
            + "00028 00028       80             MEM_READ BYTE POP\n"
            + "00029 00029       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "'     a = s[1].b;\n"
            + "0002A 0002A       38 0C          CONSTANT (1 * 12)\n"
            + "0002C 0002C       AB 02          VAR_ADDRESS VBASE+$0002\n"
            + "0002E 0002E       EC             ADD\n"
            + "0002F 0002F       A0             MEM_READ WORD POP\n"
            + "00030 00030       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "'     a = s[1].c;\n"
            + "00031 00031       38 0C          CONSTANT (1 * 12)\n"
            + "00033 00033       AB 04          VAR_ADDRESS VBASE+$0004\n"
            + "00035 00035       EC             ADD\n"
            + "00036 00036       A0             MEM_READ WORD POP\n"
            + "00037 00037       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "'     a = s[1].d;\n"
            + "00038 00038       38 0C          CONSTANT (1 * 12)\n"
            + "0003A 0003A       4B             VAR_ADDRESS VBASE+$0008 (short)\n"
            + "0003B 0003B       EC             ADD\n"
            + "0003C 0003C       C0             MEM_READ LONG POP\n"
            + "0003D 0003D       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "' }\n"
            + "0003E 0003E       32             RETURN\n"
            + "0003F 0003F       00             Padding\n"
            + "", compile(text));
    }

    @Test
    void testStructureElementArray() throws Exception {
        String text = ""
            + "struct _s {\n"
            + "    byte a;\n"
            + "    word b[4];\n"
            + "};\n"
            + "\n"
            + "struct _s s;\n"
            + "\n"
            + "void main()\n"
            + "{\n"
            + "    int a;\n"
            + "\n"
            + "    s.a = a;\n"
            + "    s.b[0] = a;\n"
            + "    s.b[1] = a;\n"
            + "\n"
            + "    a = s.a;\n"
            + "    a = s.b[0];\n"
            + "    a = s.b[1];\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 12)\n"
            + "00000 00000       20 00          Object size\n"
            + "00002 00002       02             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       08 00 04 00    Function main @ $0008 (local size 4)\n"
            + "' void main() {\n"
            + "'     s.a = a;\n"
            + "00008 00008       64             VAR_READ LONG DBASE+$0004 (short)\n"
            + "00009 00009       89 00          VAR_WRITE BYTE VBASE+$0000\n"
            + "'     s.b[0] = a;\n"
            + "0000B 0000B       64             VAR_READ LONG DBASE+$0004 (short)\n"
            + "0000C 0000C       35             CONSTANT (0)\n"
            + "0000D 0000D       B9 02          VAR_WRITE_INDEXED WORD VBASE+$0002\n"
            + "'     s.b[1] = a;\n"
            + "0000F 0000F       64             VAR_READ LONG DBASE+$0004 (short)\n"
            + "00010 00010       36             CONSTANT (1)\n"
            + "00011 00011       B9 02          VAR_WRITE_INDEXED WORD VBASE+$0002\n"
            + "'     a = s.a;\n"
            + "00013 00013       88 00          VAR_READ BYTE VBASE+$0000\n"
            + "00015 00015       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "'     a = s.b[0];\n"
            + "00016 00016       35             CONSTANT (0)\n"
            + "00017 00017       B8 02          VAR_READ_INDEXED WORD VBASE+$0002\n"
            + "00019 00019       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "'     a = s.b[1];\n"
            + "0001A 0001A       36             CONSTANT (1)\n"
            + "0001B 0001B       B8 02          VAR_READ_INDEXED WORD VBASE+$0002\n"
            + "0001D 0001D       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "' }\n"
            + "0001E 0001E       32             RETURN\n"
            + "0001F 0001F       00             Padding\n"
            + "", compile(text));
    }

    @Test
    void testStructureArrayElementArray() throws Exception {
        String text = ""
            + "struct _s {\n"
            + "    byte a;\n"
            + "    word b[4];\n"
            + "};\n"
            + "\n"
            + "struct _s s[2];\n"
            + "\n"
            + "void main()\n"
            + "{\n"
            + "    int a;\n"
            + "\n"
            + "    s[2].a = a;\n"
            + "    s[2].b[0] = a;\n"
            + "    s[2].b[1] = a;\n"
            + "\n"
            + "    a = s[2].a;\n"
            + "    a = s[2].b[0];\n"
            + "    a = s[2].b[1];\n"
            + "}\n"
            + "";

        Assertions.assertEquals(""
            + "' Object header (var size 20)\n"
            + "00000 00000       38 00          Object size\n"
            + "00002 00002       02             Method count + 1\n"
            + "00003 00003       00             Object count\n"
            + "00004 00004       08 00 04 00    Function main @ $0008 (local size 4)\n"
            + "' void main() {\n"
            + "'     s[2].a = a;\n"
            + "00008 00008       64             VAR_READ LONG DBASE+$0004 (short)\n"
            + "00009 00009       38 14          CONSTANT (2 * 10)\n"
            + "0000B 0000B       8B 00          VAR_ADDRESS VBASE+$0000\n"
            + "0000D 0000D       EC             ADD\n"
            + "0000E 0000E       81             MEM_WRITE BYTE POP\n"
            + "'     s[2].b[0] = a;\n"
            + "0000F 0000F       64             VAR_READ LONG DBASE+$0004 (short)\n"
            + "00010 00010       38 14          CONSTANT (2 * 10)\n"
            + "00012 00012       AB 02          VAR_ADDRESS VBASE+$0002\n"
            + "00014 00014       EC             ADD\n"
            + "00015 00015       35             CONSTANT (0)\n"
            + "00016 00016       B1             MEM_WRITE_INDEXED WORD POP\n"
            + "'     s[2].b[1] = a;\n"
            + "00017 00017       64             VAR_READ LONG DBASE+$0004 (short)\n"
            + "00018 00018       38 14          CONSTANT (2 * 10)\n"
            + "0001A 0001A       AB 02          VAR_ADDRESS VBASE+$0002\n"
            + "0001C 0001C       EC             ADD\n"
            + "0001D 0001D       36             CONSTANT (1)\n"
            + "0001E 0001E       B1             MEM_WRITE_INDEXED WORD POP\n"
            + "'     a = s[2].a;\n"
            + "0001F 0001F       38 14          CONSTANT (2 * 10)\n"
            + "00021 00021       8B 00          VAR_ADDRESS VBASE+$0000\n"
            + "00023 00023       EC             ADD\n"
            + "00024 00024       80             MEM_READ BYTE POP\n"
            + "00025 00025       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "'     a = s[2].b[0];\n"
            + "00026 00026       38 14          CONSTANT (2 * 10)\n"
            + "00028 00028       AB 02          VAR_ADDRESS VBASE+$0002\n"
            + "0002A 0002A       EC             ADD\n"
            + "0002B 0002B       35             CONSTANT (0)\n"
            + "0002C 0002C       B0             MEM_READ_INDEXED WORD POP\n"
            + "0002D 0002D       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "'     a = s[2].b[1];\n"
            + "0002E 0002E       38 14          CONSTANT (2 * 10)\n"
            + "00030 00030       AB 02          VAR_ADDRESS VBASE+$0002\n"
            + "00032 00032       EC             ADD\n"
            + "00033 00033       36             CONSTANT (1)\n"
            + "00034 00034       B0             MEM_READ_INDEXED WORD POP\n"
            + "00035 00035       65             VAR_WRITE LONG DBASE+$0004 (short)\n"
            + "' }\n"
            + "00036 00036       32             RETURN\n"
            + "00037 00037       00             Padding\n"
            + "", compile(text));
    }

    String compile(String text) throws Exception {
        CTokenStream stream = new CTokenStream(text);
        CParser subject = new CParser(stream);
        Node root = subject.parse();

        Spin1CObjectCompiler compiler = new Spin1CObjectCompiler(new Spin1Compiler(), new File("test.spin1"));
        Spin1Object obj = compiler.compileObject(root);

        for (CompilerException msg : compiler.getMessages()) {
            if (msg.type == CompilerException.ERROR) {
                throw msg;
            }
        }

        ByteArrayOutputStream os = new ByteArrayOutputStream();
        obj.generateListing(new PrintStream(os));

        return os.toString().replaceAll("\\r\\n", "\n");
    }

}
